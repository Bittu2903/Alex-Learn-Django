export const interviewData = {
  categories: [
    {
      title: "Django Fundamentals & Architecture",
      icon: "database",
      story: {
        title: "Alex's First Day at TechCorp",
        content: "Alex walks into TechCorp as a senior Django developer. The CTO wants to understand how well Alex knows Django's core architecture. 'Tell me about Django's philosophy and how it differs from other frameworks,' the CTO begins. Alex needs to demonstrate deep understanding of Django's principles and architectural decisions.",
        context: "This category tests your foundational knowledge of Django's architecture, MVT pattern, and core principles."
      },
      questions: [
        {
          id: "fund_1",
          question: "Explain Django's MVT (Model-View-Template) architecture and how it differs from MVC.",
          answer: "Django follows the MVT pattern:\n\n• Model: Handles data and business logic, defines database schema\n• View: Contains the application logic, processes requests and returns responses\n• Template: Handles the presentation layer, renders HTML\n\nKey differences from MVC:\n• Django's 'View' is like MVC's 'Controller'\n• Django's 'Template' is like MVC's 'View'\n• Django handles URL routing separately through URLconf\n• The framework itself acts as the 'Controller' in MVC terms",
          difficulty: "intermediate",
          tags: ["architecture", "mvt", "design-patterns"],
          codeExample: "# views.py\ndef book_list(request):\n    books = Book.objects.all()  # Model\n    return render(request, 'books/list.html', {'books': books})  # Template\n\n# urls.py\nurlpatterns = [\n    path('books/', views.book_list, name='book_list'),\n]",
          followUp: "How does Django's URL dispatcher fit into the MVT pattern?"
        },
        {
          id: "fund_2",
          question: "What is Django's philosophy and what are its core principles?",
          answer: "Django follows several key principles:\n\n• DRY (Don't Repeat Yourself): Avoid code duplication\n• Convention over Configuration: Sensible defaults reduce boilerplate\n• Loose Coupling: Components should be independent\n• Explicit is better than implicit: Clear, readable code\n• Batteries included: Rich set of built-in features\n• The principle of least surprise: Intuitive behavior\n• Fast development: Rapid prototyping and deployment",
          difficulty: "beginner",
          tags: ["philosophy", "principles", "design"],
          followUp: "How do these principles influence Django's design decisions?"
        },
        {
          id: "fund_3",
          question: "Explain Django's request-response cycle in detail.",
          answer: "The Django request-response cycle:\n\n1. Browser sends HTTP request to Django server\n2. Django's WSGI handler receives the request\n3. URL dispatcher matches URL patterns in URLconf\n4. Middleware processes the request (authentication, CSRF, etc.)\n5. View function is called with HttpRequest object\n6. View processes the request, interacts with models\n7. View returns HttpResponse object\n8. Middleware processes the response\n9. Response is sent back to the browser",
          difficulty: "intermediate",
          tags: ["request-cycle", "middleware", "urls"],
          codeExample: "# Simplified flow\nclass MyMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n    \n    def __call__(self, request):\n        # Process request\n        response = self.get_response(request)\n        # Process response\n        return response",
          followUp: "Where in this cycle would you implement custom authentication logic?"
        },
        {
          id: "fund_4",
          question: "What are Django apps and how do they promote reusability?",
          answer: "Django apps are self-contained modules that handle specific functionality:\n\n• Each app focuses on one aspect of the project\n• Apps can be reused across different projects\n• Apps should be loosely coupled\n• Each app has its own models, views, templates, and URLs\n• Apps can be distributed as packages\n\nBenefits:\n• Modularity and separation of concerns\n• Easier testing and maintenance\n• Code reusability\n• Team collaboration\n• Third-party app ecosystem",
          difficulty: "beginner",
          tags: ["apps", "modularity", "reusability"],
          codeExample: "# Project structure\nmyproject/\n    manage.py\n    myproject/\n        settings.py\n        urls.py\n    blog/  # App\n        models.py\n        views.py\n        urls.py\n    shop/  # Another app\n        models.py\n        views.py\n        urls.py",
          followUp: "How would you design apps for an e-commerce platform?"
        },
        {
          id: "fund_5",
          question: "Explain Django's settings system and how to manage different environments.",
          answer: "Django's settings system manages configuration:\n\n• settings.py contains all configuration variables\n• Environment-specific settings for dev, staging, production\n• Use environment variables for sensitive data\n• Settings modules for different environments\n• django-environ for .env file support\n\nBest practices:\n• Keep secrets out of version control\n• Use different settings files per environment\n• Validate settings on startup\n• Document all custom settings",
          difficulty: "intermediate",
          tags: ["settings", "configuration", "environment"],
          codeExample: "# settings/base.py\nDEBUG = False\nSECRET_KEY = os.environ.get('SECRET_KEY')\n\n# settings/development.py\nfrom .base import *\nDEBUG = True\n\n# settings/production.py\nfrom .base import *\nALLOWED_HOSTS = ['example.com']\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': os.environ.get('DB_NAME'),\n    }\n}",
          followUp: "How would you handle feature flags in Django settings?"
        },
        {
          id: "fund_6",
          question: "What is Django's ORM and what are its advantages and limitations?",
          answer: "Django ORM (Object-Relational Mapping) advantages:\n\n• Database abstraction layer\n• Pythonic syntax for database queries\n• Automatic SQL generation\n• Database migration system\n• Protection against SQL injection\n• Lazy query evaluation\n• Query optimization\n\nLimitations:\n• Complex queries may be inefficient\n• Learning curve for advanced features\n• Sometimes raw SQL is needed\n• Limited support for database-specific features\n• Can generate suboptimal queries",
          difficulty: "intermediate",
          tags: ["orm", "database", "queries"],
          codeExample: "# ORM examples\n# Simple query\nusers = User.objects.filter(is_active=True)\n\n# Complex query\nexpensive_orders = Order.objects.filter(\n    total__gt=1000,\n    created_at__year=2023\n).select_related('user').prefetch_related('items')",
          followUp: "When would you choose raw SQL over Django ORM?"
        },
        {
          id: "fund_7",
          question: "How does Django handle URL routing and what are the best practices?",
          answer: "Django URL routing uses URLconf (URL configuration):\n\n• URL patterns map URLs to views\n• Supports path converters and regular expressions\n• Named URLs for reverse lookup\n• URL namespacing for apps\n• Include other URLconfs\n\nBest practices:\n• Use path() over re_path() when possible\n• Name all URL patterns\n• Use app namespaces\n• Keep URLs RESTful\n• Use URL parameters for dynamic content\n• Organize URLs logically",
          difficulty: "intermediate",
          tags: ["urls", "routing", "best-practices"],
          codeExample: "# myproject/urls.py\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('blog/', include('blog.urls', namespace='blog')),\n    path('api/v1/', include('api.urls')),\n]\n\n# blog/urls.py\napp_name = 'blog'\nurlpatterns = [\n    path('', views.post_list, name='post_list'),\n    path('<int:pk>/', views.post_detail, name='post_detail'),\n]",
          followUp: "How would you implement API versioning in Django URLs?"
        },
        {
          id: "fund_8",
          question: "What is WSGI and how does Django use it?",
          answer: "WSGI (Web Server Gateway Interface) is a Python standard:\n\n• Interface between web servers and Python web applications\n• Django creates a WSGI application object\n• WSGI servers (Gunicorn, uWSGI) serve Django apps\n• Handles HTTP requests and responses\n• Supports middleware at WSGI level\n• Enables deployment flexibility\n\nDjango's WSGI:\n• wsgi.py file contains the WSGI application\n• get_wsgi_application() creates the app\n• Can be customized for specific needs\n• Supports ASGI for async operations",
          difficulty: "advanced",
          tags: ["wsgi", "deployment", "servers"],
          codeExample: "# wsgi.py\nimport os\nfrom django.core.wsgi import get_wsgi_application\n\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')\napplication = get_wsgi_application()\n\n# Custom WSGI middleware\nclass CustomWSGIMiddleware:\n    def __init__(self, application):\n        self.application = application\n    \n    def __call__(self, environ, start_response):\n        # Process request\n        return self.application(environ, start_response)",
          followUp: "How would you implement custom WSGI middleware for logging?"
        }
      ]
    },
    {
      title: "Models & Database Operations",
      icon: "database",
      story: {
        title: "Database Migration Crisis",
        content: "It's 2 AM and the production database is acting strange. Alex gets a call from the ops team - there's a data integrity issue that needs immediate attention. The previous developer left complex model relationships that are causing cascading deletes. Alex needs to demonstrate expertise in Django models, relationships, and database operations to fix this critical issue.",
        context: "This section tests your knowledge of Django models, database relationships, queries, and migrations."
      },
      questions: [
        {
          id: "model_1",
          question: "Explain Django model relationships (ForeignKey, OneToOneField, ManyToManyField) with examples.",
          answer: "Django model relationships:\n\n• ForeignKey: Many-to-one relationship\n• OneToOneField: One-to-one relationship\n• ManyToManyField: Many-to-many relationship\n\nKey concepts:\n• related_name for reverse lookups\n• on_delete behavior for ForeignKey\n• through models for M2M with extra fields\n• select_related() and prefetch_related() for optimization",
          difficulty: "intermediate",
          tags: ["models", "relationships", "database"],
          codeExample: "class Author(models.Model):\n    name = models.CharField(max_length=100)\n    email = models.EmailField()\n\nclass Book(models.Model):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(\n        Author, \n        on_delete=models.CASCADE, \n        related_name='books'\n    )\n    categories = models.ManyToManyField(\n        'Category', \n        through='BookCategory'\n    )\n\nclass BookCategory(models.Model):\n    book = models.ForeignKey(Book, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.CASCADE)\n    featured = models.BooleanField(default=False)",
          followUp: "How would you handle a circular import in model relationships?"
        },
        {
          id: "model_2",
          question: "What are Django migrations and how do you handle complex migration scenarios?",
          answer: "Django migrations track database schema changes:\n\n• Automatically generated from model changes\n• Version control for database schema\n• Forward and reverse migrations\n• Data migrations for complex changes\n• Squashing migrations for optimization\n\nComplex scenarios:\n• Custom migration operations\n• RunPython for data transformations\n• Atomic migrations\n• Zero-downtime deployments\n• Handling conflicts in team environments",
          difficulty: "advanced",
          tags: ["migrations", "database", "schema"],
          codeExample: "# Custom data migration\nfrom django.db import migrations\n\ndef populate_slugs(apps, schema_editor):\n    Article = apps.get_model('blog', 'Article')\n    for article in Article.objects.all():\n        article.slug = article.title.lower().replace(' ', '-')\n        article.save()\n\nclass Migration(migrations.Migration):\n    dependencies = [\n        ('blog', '0001_initial'),\n    ]\n    \n    operations = [\n        migrations.RunPython(populate_slugs),\n    ]",
          followUp: "How would you implement zero-downtime migrations for a large table?"
        },
        {
          id: "model_3",
          question: "Explain Django QuerySet optimization techniques and common performance pitfalls.",
          answer: "QuerySet optimization techniques:\n\n• select_related() for ForeignKey/OneToOne\n• prefetch_related() for ManyToMany/reverse FK\n• only() and defer() for field selection\n• bulk_create() and bulk_update() for bulk operations\n• Database indexes for frequently queried fields\n• Query annotation and aggregation\n• Raw SQL for complex queries\n\nCommon pitfalls:\n• N+1 query problems\n• Unnecessary database hits\n• Large result sets without pagination\n• Missing database indexes\n• Inefficient filters and lookups",
          difficulty: "advanced",
          tags: ["queryset", "optimization", "performance"],
          codeExample: "# Optimized queries\n# Bad - N+1 problem\nfor book in Book.objects.all():\n    print(book.author.name)  # DB hit for each book\n\n# Good - select_related\nfor book in Book.objects.select_related('author'):\n    print(book.author.name)  # Single query\n\n# Bulk operations\nBook.objects.bulk_create([\n    Book(title='Book 1', author_id=1),\n    Book(title='Book 2', author_id=2),\n])\n\n# Aggregation\nfrom django.db.models import Count, Avg\nauthor_stats = Author.objects.annotate(\n    book_count=Count('books'),\n    avg_rating=Avg('books__rating')\n)",
          followUp: "How would you debug slow Django queries in production?"
        },
        {
          id: "model_4",
          question: "What are Django model managers and when would you create custom ones?",
          answer: "Django model managers control QuerySet behavior:\n\n• Default manager: objects\n• Custom managers for common queries\n• Manager methods return QuerySets\n• Can override get_queryset() for default filtering\n• Use for business logic encapsulation\n\nUse cases:\n• Soft deletes\n• Filtering by status\n• Company-specific data\n• Complex query logic\n• Performance optimizations",
          difficulty: "intermediate",
          tags: ["managers", "models", "abstraction"],
          codeExample: "class PublishedManager(models.Manager):\n    def get_queryset(self):\n        return super().get_queryset().filter(status='published')\n    \n    def featured(self):\n        return self.get_queryset().filter(featured=True)\n\nclass SoftDeleteManager(models.Manager):\n    def get_queryset(self):\n        return super().get_queryset().filter(deleted_at__isnull=True)\n    \n    def with_deleted(self):\n        return super().get_queryset()\n\nclass Article(models.Model):\n    title = models.CharField(max_length=200)\n    status = models.CharField(max_length=20)\n    deleted_at = models.DateTimeField(null=True, blank=True)\n    \n    objects = SoftDeleteManager()\n    published = PublishedManager()\n    all_objects = models.Manager()  # Default manager",
          followUp: "How would you implement a manager for multi-tenant applications?"
        },
        {
          id: "model_5",
          question: "Explain Django model inheritance and when to use each type.",
          answer: "Django model inheritance types:\n\n• Abstract base classes: Share common fields\n• Multi-table inheritance: Separate tables with joins\n• Proxy models: Different behavior, same table\n\nWhen to use:\n• Abstract: Common fields across models\n• Multi-table: Different types of similar objects\n• Proxy: Different managers or methods\n\nConsiderations:\n• Performance implications\n• Query complexity\n• Maintainability\n• Database normalization",
          difficulty: "advanced",
          tags: ["inheritance", "models", "database-design"],
          codeExample: "# Abstract base class\nclass TimeStampedModel(models.Model):\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    \n    class Meta:\n        abstract = True\n\n# Multi-table inheritance\nclass Place(models.Model):\n    name = models.CharField(max_length=50)\n    address = models.CharField(max_length=80)\n\nclass Restaurant(Place):\n    serves_hot_dogs = models.BooleanField(default=False)\n    serves_pizza = models.BooleanField(default=False)\n\n# Proxy model\nclass OrderedPerson(Person):\n    class Meta:\n        proxy = True\n        ordering = ['last_name']",
          followUp: "What are the performance implications of multi-table inheritance?"
        },
        {
          id: "model_6",
          question: "How do you handle database transactions in Django?",
          answer: "Django transaction management:\n\n• Database-level ACID properties\n• Autocommit mode by default\n• transaction.atomic() decorator/context manager\n• Manual transaction control\n• Savepoints for nested transactions\n• Database-level constraints\n\nBest practices:\n• Use atomic for consistency\n• Handle transaction errors properly\n• Avoid long-running transactions\n• Consider transaction isolation levels\n• Use select_for_update() for row locking",
          difficulty: "advanced",
          tags: ["transactions", "database", "consistency"],
          codeExample: "from django.db import transaction\n\n# Decorator\n@transaction.atomic\ndef create_order(user, items):\n    order = Order.objects.create(user=user)\n    for item in items:\n        OrderItem.objects.create(order=order, **item)\n    return order\n\n# Context manager\ndef transfer_money(from_account, to_account, amount):\n    with transaction.atomic():\n        from_account.balance -= amount\n        from_account.save()\n        to_account.balance += amount\n        to_account.save()\n\n# Savepoint\ndef complex_operation():\n    with transaction.atomic():\n        # Main operation\n        try:\n            with transaction.atomic():\n                # Risky operation\n                pass\n        except Exception:\n            # Handle error, main transaction continues\n            pass",
          followUp: "How would you implement distributed transactions across multiple databases?"
        },
        {
          id: "model_7",
          question: "What are Django signals and how do you use them effectively?",
          answer: "Django signals enable decoupled communication:\n\n• pre_save/post_save: Before/after model save\n• pre_delete/post_delete: Before/after deletion\n• m2m_changed: ManyToMany field changes\n• request_started/request_finished: Request lifecycle\n• Custom signals for application events\n\nBest practices:\n• Use for side effects, not core logic\n• Handle exceptions properly\n• Be mindful of performance\n• Use weak references\n• Test signal handlers",
          difficulty: "intermediate",
          tags: ["signals", "events", "decoupling"],
          codeExample: "from django.db.models.signals import post_save\nfrom django.dispatch import receiver\n\n@receiver(post_save, sender=User)\ndef create_user_profile(sender, instance, created, **kwargs):\n    if created:\n        UserProfile.objects.create(user=instance)\n\n# Custom signal\nimport django.dispatch\norder_placed = django.dispatch.Signal()\n\n@receiver(order_placed)\ndef send_order_confirmation(sender, order, **kwargs):\n    send_email(order.user.email, 'Order Confirmation', order)\n\n# Sending signal\norder_placed.send(sender=Order, order=order)",
          followUp: "How would you implement an event sourcing pattern using Django signals?"
        },
        {
          id: "model_8",
          question: "Explain Django model validation and custom validators.",
          answer: "Django model validation layers:\n\n• Field-level validation\n• Model-level validation (clean method)\n• Form validation\n• Custom validators\n• Database constraints\n\nValidation process:\n• Field validation first\n• Model clean() method\n• Model clean_<fieldname>() methods\n• Database constraints last\n\nCustom validators:\n• Function-based validators\n• Class-based validators\n• Reusable across models/forms",
          difficulty: "intermediate",
          tags: ["validation", "models", "data-integrity"],
          codeExample: "from django.core.exceptions import ValidationError\nfrom django.core.validators import RegexValidator\n\ndef validate_isbn(value):\n    if len(value) != 13 or not value.isdigit():\n        raise ValidationError('ISBN must be 13 digits')\n\nclass Book(models.Model):\n    title = models.CharField(max_length=200)\n    isbn = models.CharField(\n        max_length=13, \n        validators=[validate_isbn]\n    )\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n    \n    def clean(self):\n        if self.price < 0:\n            raise ValidationError('Price cannot be negative')\n    \n    def clean_title(self):\n        if 'banned' in self.title.lower():\n            raise ValidationError('Title contains banned words')",
          followUp: "How would you implement conditional validation based on other field values?"
        }
      ]
    },
    {
      title: "Views & URL Patterns",
      icon: "globe",
      story: {
        title: "API Architecture Challenge",
        content: "The startup Alex joined is scaling rapidly. They need to build a robust API that can handle thousands of concurrent users. The lead architect asks Alex to design a view architecture that's both performant and maintainable. 'Show me how you'd structure views for a complex e-commerce API,' she says, 'and explain how you'd handle authentication, permissions, and error handling.'",
        context: "This section covers Django views, URL patterns, API design, and request handling."
      },
      questions: [
        {
          id: "view_1",
          question: "Compare function-based views vs class-based views. When would you use each?",
          answer: "Function-based views (FBVs) vs Class-based views (CBVs):\n\nFBVs:\n• Simple and straightforward\n• Easy to understand and debug\n• Direct control over request handling\n• Good for simple, unique logic\n• Less code for basic operations\n\nCBVs:\n• Built-in mixins for common patterns\n• Inheritance and method overriding\n• Better code reuse\n• More complex but powerful\n• Better for CRUD operations\n\nUse FBVs for:\n• Simple views\n• Custom business logic\n• API endpoints with unique requirements\n\nUse CBVs for:\n• CRUD operations\n• Complex forms\n• When you need mixins\n• RESTful APIs",
          difficulty: "intermediate",
          tags: ["views", "fbv", "cbv", "architecture"],
          codeExample: "# Function-based view\ndef book_list(request):\n    if request.method == 'GET':\n        books = Book.objects.all()\n        return JsonResponse({'books': list(books.values())})\n    elif request.method == 'POST':\n        # Handle POST\n        pass\n\n# Class-based view\nclass BookListView(ListView):\n    model = Book\n    template_name = 'books/list.html'\n    context_object_name = 'books'\n    paginate_by = 10\n    \n    def get_queryset(self):\n        return Book.objects.filter(published=True)",
          followUp: "How would you implement custom pagination in a class-based view?"
        },
        {
          id: "view_2",
          question: "Explain Django's generic views and how to customize them.",
          answer: "Django generic views provide common patterns:\n\n• ListView: Display multiple objects\n• DetailView: Display single object\n• CreateView: Create new objects\n• UpdateView: Update existing objects\n• DeleteView: Delete objects\n• FormView: Handle forms\n• TemplateView: Render templates\n\nCustomization methods:\n• Override get_queryset()\n• Override get_context_data()\n• Override form_valid()/form_invalid()\n• Custom mixins\n• Override HTTP methods",
          difficulty: "intermediate",
          tags: ["generic-views", "customization", "mixins"],
          codeExample: "class BookListView(ListView):\n    model = Book\n    template_name = 'books/list.html'\n    context_object_name = 'books'\n    paginate_by = 10\n    \n    def get_queryset(self):\n        queryset = super().get_queryset()\n        search = self.request.GET.get('search')\n        if search:\n            queryset = queryset.filter(title__icontains=search)\n        return queryset.select_related('author')\n    \n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context['search_form'] = SearchForm()\n        context['categories'] = Category.objects.all()\n        return context",
          followUp: "How would you implement custom filtering with multiple parameters?"
        },
        {
          id: "view_3",
          question: "How do you handle HTTP methods and content negotiation in Django views?",
          answer: "HTTP method handling:\n\n• dispatch() method routes to appropriate handlers\n• get(), post(), put(), delete() methods\n• http_method_not_allowed() for unsupported methods\n• require_http_methods() decorator\n• Method-specific logic\n\nContent negotiation:\n• Accept headers for response format\n• Content-Type for request format\n• Django REST framework for APIs\n• Custom content type handling\n• Format suffixes (.json, .xml)",
          difficulty: "intermediate",
          tags: ["http-methods", "content-negotiation", "api"],
          codeExample: "from django.views.decorators.http import require_http_methods\nfrom django.views.generic import View\nfrom django.http import JsonResponse\n\n@require_http_methods(['GET', 'POST'])\ndef book_api(request):\n    if request.method == 'GET':\n        books = Book.objects.all()\n        return JsonResponse({'books': list(books.values())})\n    elif request.method == 'POST':\n        # Handle POST\n        pass\n\nclass BookAPIView(View):\n    def dispatch(self, request, *args, **kwargs):\n        # Custom dispatch logic\n        return super().dispatch(request, *args, **kwargs)\n    \n    def get(self, request):\n        accept = request.META.get('HTTP_ACCEPT', '')\n        if 'application/json' in accept:\n            return JsonResponse({'books': []})\n        return render(request, 'books/list.html')",
          followUp: "How would you implement API versioning in Django views?"
        },
        {
          id: "view_4",
          question: "Explain Django middleware and how to create custom middleware.",
          answer: "Django middleware processes requests and responses:\n\n• Executes before and after view processing\n• Can modify request/response objects\n• Authentication, security, caching\n• CORS, logging, monitoring\n• Request/response transformation\n\nMiddleware order matters:\n• SecurityMiddleware first\n• SessionMiddleware before AuthenticationMiddleware\n• AuthenticationMiddleware before view\n• Custom middleware positioning\n\nCustom middleware:\n• __init__() and __call__() methods\n• process_view() for view-specific logic\n• process_exception() for error handling",
          difficulty: "advanced",
          tags: ["middleware", "request-processing", "custom"],
          codeExample: "class RequestLoggingMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n    \n    def __call__(self, request):\n        # Process request\n        start_time = time.time()\n        \n        response = self.get_response(request)\n        \n        # Process response\n        duration = time.time() - start_time\n        logger.info(f'{request.method} {request.path} - {response.status_code} - {duration:.2f}s')\n        \n        return response\n    \n    def process_view(self, request, view_func, view_args, view_kwargs):\n        # Called before view\n        request.view_name = view_func.__name__\n        \n    def process_exception(self, request, exception):\n        # Handle exceptions\n        logger.error(f'Exception in {request.path}: {exception}')\n        return None",
          followUp: "How would you implement rate limiting using custom middleware?"
        },
        {
          id: "view_5",
          question: "How do you handle file uploads in Django views?",
          answer: "Django file upload handling:\n\n• request.FILES contains uploaded files\n• FileField and ImageField in models\n• Form validation for file uploads\n• Storage backends for file handling\n• Security considerations\n• Progress tracking for large files\n\nBest practices:\n• Validate file types and sizes\n• Use secure file storage\n• Generate unique filenames\n• Implement virus scanning\n• Handle upload errors gracefully\n• Consider cloud storage for production",
          difficulty: "intermediate",
          tags: ["file-uploads", "security", "storage"],
          codeExample: "from django.core.files.storage import default_storage\nfrom django.core.files.base import ContentFile\n\nclass DocumentUploadView(View):\n    def post(self, request):\n        if 'document' not in request.FILES:\n            return JsonResponse({'error': 'No file uploaded'})\n        \n        uploaded_file = request.FILES['document']\n        \n        # Validate file\n        if uploaded_file.size > 10 * 1024 * 1024:  # 10MB limit\n            return JsonResponse({'error': 'File too large'})\n        \n        allowed_types = ['application/pdf', 'image/jpeg', 'image/png']\n        if uploaded_file.content_type not in allowed_types:\n            return JsonResponse({'error': 'Invalid file type'})\n        \n        # Save file\n        filename = default_storage.save(\n            f'documents/{uploaded_file.name}',\n            ContentFile(uploaded_file.read())\n        )\n        \n        # Create model instance\n        document = Document.objects.create(\n            title=uploaded_file.name,\n            file=filename,\n            uploaded_by=request.user\n        )\n        \n        return JsonResponse({'id': document.id, 'filename': filename})",
          followUp: "How would you implement chunked file upload for large files?"
        },
        {
          id: "view_6",
          question: "Explain Django's URL patterns and advanced routing techniques.",
          answer: "Django URL patterns:\n\n• path() for simple patterns\n• re_path() for regex patterns\n• Path converters (int, slug, uuid)\n• URL namespacing\n• include() for modularity\n• Named URL patterns\n• Reverse URL lookup\n\nAdvanced techniques:\n• Custom path converters\n• Conditional URL patterns\n• URL versioning\n• Internationalization (i18n_patterns)\n• Subdomain routing\n• Dynamic URL generation",
          difficulty: "advanced",
          tags: ["urls", "routing", "patterns"],
          codeExample: "# Custom path converter\nclass YearConverter:\n    regex = '[0-9]{4}'\n    \n    def to_python(self, value):\n        return int(value)\n    \n    def to_url(self, value):\n        return f'{value:04d}'\n\n# Register converter\nfrom django.urls import register_converter\nregister_converter(YearConverter, 'yyyy')\n\n# URL patterns\nurlpatterns = [\n    path('articles/<yyyy:year>/', views.year_archive),\n    path('articles/<yyyy:year>/<int:month>/', views.month_archive),\n    path('api/v<int:version>/', include('api.urls')),\n    re_path(r'^blog/(?P<slug>[-\\w]+)/$', views.post_detail),\n]\n\n# Conditional patterns\nif settings.DEBUG:\n    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)",
          followUp: "How would you implement subdomain-based routing in Django?"
        },
        {
          id: "view_7",
          question: "How do you implement caching in Django views?",
          answer: "Django caching strategies:\n\n• Page-level caching\n• Template fragment caching\n• Low-level cache API\n• Database query caching\n• View-level caching decorators\n• Cache invalidation strategies\n\nCaching backends:\n• Redis for distributed caching\n• Memcached for simple caching\n• Database caching for development\n• File-based caching\n• Dummy cache for testing\n\nBest practices:\n• Cache expensive operations\n• Use appropriate cache keys\n• Implement cache warming\n• Handle cache misses gracefully\n• Monitor cache hit rates",
          difficulty: "advanced",
          tags: ["caching", "performance", "optimization"],
          codeExample: "from django.core.cache import cache\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.vary import vary_on_headers\n\n# Page caching\n@cache_page(60 * 15)  # Cache for 15 minutes\ndef product_list(request):\n    products = Product.objects.all()\n    return render(request, 'products/list.html', {'products': products})\n\n# Manual caching\ndef expensive_view(request):\n    cache_key = f'expensive_data_{request.user.id}'\n    data = cache.get(cache_key)\n    \n    if data is None:\n        # Expensive operation\n        data = perform_expensive_calculation()\n        cache.set(cache_key, data, 60 * 60)  # Cache for 1 hour\n    \n    return JsonResponse({'data': data})\n\n# Template fragment caching\n# In template:\n# {% load cache %}\n# {% cache 500 sidebar request.user.id %}\n#     <!-- Expensive sidebar content -->\n# {% endcache %}",
          followUp: "How would you implement cache warming for critical data?"
        },
        {
          id: "view_8",
          question: "Explain error handling and custom error pages in Django.",
          answer: "Django error handling:\n\n• HTTP error codes (400, 403, 404, 500)\n• Custom error views\n• Exception handling in views\n• Logging and monitoring\n• User-friendly error messages\n• Debug vs production behavior\n\nCustom error pages:\n• 400.html, 403.html, 404.html, 500.html\n• Context available in error templates\n• Custom error view functions\n• CSRF error handling\n• Permission denied handling\n\nBest practices:\n• Log all errors\n• Provide helpful error messages\n• Don't expose sensitive information\n• Implement proper error monitoring\n• Test error scenarios",
          difficulty: "intermediate",
          tags: ["error-handling", "debugging", "monitoring"],
          codeExample: "# Custom error views\ndef custom_404(request, exception):\n    return render(request, 'errors/404.html', {\n        'exception': exception,\n        'request_path': request.path\n    }, status=404)\n\ndef custom_500(request):\n    return render(request, 'errors/500.html', status=500)\n\n# In urls.py\nhandler404 = 'myapp.views.custom_404'\nhandler500 = 'myapp.views.custom_500'\n\n# View error handling\nclass ProductDetailView(DetailView):\n    model = Product\n    \n    def get_object(self, queryset=None):\n        try:\n            return super().get_object(queryset)\n        except Product.DoesNotExist:\n            logger.warning(f'Product not found: {self.kwargs.get(\"pk\")}')\n            raise Http404('Product not found')\n    \n    def handle_no_permission(self):\n        messages.error(self.request, 'You do not have permission to view this product')\n        return redirect('product_list')",
          followUp: "How would you implement structured error logging with request context?"
        }
      ]
    },
    {
      title: "Authentication & Security",
      icon: "shield",
      story: {
        title: "Security Breach Response",
        content: "Alex's phone buzzes at 3 AM. There's been a security incident - someone tried to exploit the authentication system. The security team needs Alex to quickly assess the current security measures and implement additional protections. 'Walk me through Django's security features and how you'd implement a robust authentication system,' the security lead asks urgently.",
        context: "This section covers Django's security features, authentication, authorization, and security best practices."
      },
      questions: [
        {
          id: "security_1",
          question: "Explain Django's authentication system and how to customize it.",
          answer: "Django authentication system:\n\n• User model with username/password\n• Authentication backends\n• Login/logout views\n• Password validation\n• Permission system\n• Group-based permissions\n• Session management\n\nCustomization options:\n• Custom User model\n• Custom authentication backends\n• Custom login/logout views\n• Third-party authentication (OAuth, SAML)\n• Multi-factor authentication\n• Custom password validators\n• Custom permission classes",
          difficulty: "intermediate",
          tags: ["authentication", "user-model", "security"],
          codeExample: "# Custom User model\nfrom django.contrib.auth.models import AbstractUser\n\nclass CustomUser(AbstractUser):\n    email = models.EmailField(unique=True)\n    phone = models.CharField(max_length=20, blank=True)\n    is_verified = models.BooleanField(default=False)\n    \n    USERNAME_FIELD = 'email'\n    REQUIRED_FIELDS = ['username']\n\n# Custom authentication backend\nclass EmailAuthBackend:\n    def authenticate(self, request, username=None, password=None, **kwargs):\n        try:\n            user = CustomUser.objects.get(email=username)\n            if user.check_password(password):\n                return user\n        except CustomUser.DoesNotExist:\n            return None\n    \n    def get_user(self, user_id):\n        try:\n            return CustomUser.objects.get(pk=user_id)\n        except CustomUser.DoesNotExist:\n            return None\n\n# In settings.py\nAUTH_USER_MODEL = 'accounts.CustomUser'\nAUTHENTICATION_BACKENDS = [\n    'accounts.backends.EmailAuthBackend',\n    'django.contrib.auth.backends.ModelBackend',\n]",
          followUp: "How would you implement social authentication with multiple providers?"
        },
        {
          id: "security_2",
          question: "What are Django's built-in security features and how do they work?",
          answer: "Django security features:\n\n• CSRF protection: Prevents cross-site request forgery\n• SQL injection protection: Parameterized queries\n• XSS protection: Template auto-escaping\n• Clickjacking protection: X-Frame-Options header\n• SSL/HTTPS enforcement\n• Secure cookies and sessions\n• Password hashing with PBKDF2\n• Security middleware\n\nSecurity headers:\n• X-Content-Type-Options\n• X-XSS-Protection\n• Strict-Transport-Security\n• Content-Security-Policy\n• X-Frame-Options\n\nBest practices:\n• Use HTTPS in production\n• Validate all user input\n• Implement proper authentication\n• Regular security audits\n• Keep Django updated",
          difficulty: "advanced",
          tags: ["security", "csrf", "xss", "headers"],
          codeExample: "# Security settings\nSECURE_SSL_REDIRECT = True\nSECURE_HSTS_SECONDS = 31536000\nSECURE_HSTS_INCLUDE_SUBDOMAINS = True\nSECURE_HSTS_PRELOAD = True\nSECURE_CONTENT_TYPE_NOSNIFF = True\nSECURE_BROWSER_XSS_FILTER = True\nX_FRAME_OPTIONS = 'DENY'\nCSRF_COOKIE_SECURE = True\nSESSION_COOKIE_SECURE = True\n\n# Custom security middleware\nclass SecurityHeadersMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n    \n    def __call__(self, request):\n        response = self.get_response(request)\n        response['X-Content-Type-Options'] = 'nosniff'\n        response['X-Frame-Options'] = 'DENY'\n        response['X-XSS-Protection'] = '1; mode=block'\n        response['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\n        return response\n\n# CSRF protection in forms\n# In template:\n# <form method=\"post\">\n#     {% csrf_token %}\n#     <!-- form fields -->\n# </form>",
          followUp: "How would you implement Content Security Policy (CSP) in Django?"
        },
        {
          id: "security_3",
          question: "How do you implement role-based access control (RBAC) in Django?",
          answer: "Django RBAC implementation:\n\n• Groups for role management\n• Permissions for specific actions\n• User-group relationships\n• Custom permissions\n• Permission checking in views\n• Template permission checks\n• Model-level permissions\n\nAdvanced RBAC:\n• Object-level permissions\n• Dynamic permission assignment\n• Permission inheritance\n• Role hierarchies\n• Context-based permissions\n• Third-party packages (django-guardian)\n\nBest practices:\n• Principle of least privilege\n• Regular permission audits\n• Clear permission naming\n• Document permission structure\n• Test permission scenarios",
          difficulty: "advanced",
          tags: ["rbac", "permissions", "authorization"],
          codeExample: "# Custom permissions\nclass Article(models.Model):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    \n    class Meta:\n        permissions = [\n            ('publish_article', 'Can publish articles'),\n            ('feature_article', 'Can feature articles'),\n        ]\n\n# Permission-based view\nfrom django.contrib.auth.mixins import PermissionRequiredMixin\n\nclass ArticlePublishView(PermissionRequiredMixin, UpdateView):\n    model = Article\n    permission_required = 'blog.publish_article'\n    \n    def handle_no_permission(self):\n        messages.error(self.request, 'You do not have permission to publish articles')\n        return redirect('article_list')\n\n# Custom permission check\ndef user_can_edit_article(user, article):\n    return (\n        user.is_authenticated and (\n            user == article.author or\n            user.has_perm('blog.change_article') or\n            user.groups.filter(name='Editors').exists()\n        )\n    )\n\n# In template\n# {% if user.is_authenticated and 'blog.publish_article' in perms %}\n#     <a href=\"{% url 'publish_article' article.pk %}\">Publish</a>\n# {% endif %}",
          followUp: "How would you implement row-level security for multi-tenant applications?"
        },
        {
          id: "security_4",
          question: "Explain Django's password management and how to implement custom password policies.",
          answer: "Django password management:\n\n• PBKDF2 password hashing by default\n• Password validation framework\n• Built-in password validators\n• Custom password validators\n• Password reset functionality\n• Password change views\n• Password history tracking\n\nCustom password policies:\n• Minimum length requirements\n• Character complexity rules\n• Password expiration\n• Password history validation\n• Account lockout policies\n• Password strength meters\n• Multi-factor authentication\n\nSecurity considerations:\n• Strong hashing algorithms\n• Salt for password hashing\n• Secure password reset tokens\n• Rate limiting for login attempts\n• Audit logging for authentication events",
          difficulty: "intermediate",
          tags: ["passwords", "validation", "security"],
          codeExample: "# Custom password validator\nfrom django.core.exceptions import ValidationError\nfrom django.utils.translation import gettext as _\n\nclass CustomPasswordValidator:\n    def validate(self, password, user=None):\n        if not any(char.isupper() for char in password):\n            raise ValidationError(\n                _('Password must contain at least one uppercase letter.'),\n                code='password_no_upper',\n            )\n        \n        if not any(char.islower() for char in password):\n            raise ValidationError(\n                _('Password must contain at least one lowercase letter.'),\n                code='password_no_lower',\n            )\n        \n        if not any(char.isdigit() for char in password):\n            raise ValidationError(\n                _('Password must contain at least one digit.'),\n                code='password_no_digit',\n            )\n    \n    def get_help_text(self):\n        return _('Your password must contain at least one uppercase letter, one lowercase letter, and one digit.')\n\n# In settings.py\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n        'OPTIONS': {\n            'min_length': 12,\n        }\n    },\n    {\n        'NAME': 'myapp.validators.CustomPasswordValidator',\n    },\n]\n\n# Password history tracking\nclass PasswordHistory(models.Model):\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n    password_hash = models.CharField(max_length=128)\n    created_at = models.DateTimeField(auto_now_add=True)\n    \n    class Meta:\n        ordering = ['-created_at']",
          followUp: "How would you implement password-less authentication using magic links?"
        },
        {
          id: "security_5",
          question: "How do you implement API authentication and authorization in Django?",
          answer: "Django API authentication methods:\n\n• Token-based authentication\n• Session authentication\n• JWT (JSON Web Tokens)\n• OAuth 2.0 / OpenID Connect\n• API key authentication\n• Certificate-based authentication\n• Custom authentication schemes\n\nDjango REST Framework:\n• Multiple authentication classes\n• Permission classes\n• Throttling and rate limiting\n• API versioning\n• CORS handling\n\nBest practices:\n• Use HTTPS for all API endpoints\n• Implement proper token expiration\n• Rate limiting to prevent abuse\n• Input validation and sanitization\n• Audit logging for API access\n• Implement proper error handling",
          difficulty: "advanced",
          tags: ["api-auth", "tokens", "jwt", "oauth"],
          codeExample: "# Token authentication\nfrom rest_framework.authentication import TokenAuthentication\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.views import APIView\n\nclass BookAPIView(APIView):\n    authentication_classes = [TokenAuthentication]\n    permission_classes = [IsAuthenticated]\n    \n    def get(self, request):\n        books = Book.objects.all()\n        serializer = BookSerializer(books, many=True)\n        return Response(serializer.data)\n\n# Custom JWT authentication\nfrom rest_framework_simplejwt.authentication import JWTAuthentication\nfrom rest_framework_simplejwt.tokens import RefreshToken\n\nclass CustomJWTAuthentication(JWTAuthentication):\n    def authenticate(self, request):\n        # Custom JWT validation logic\n        header = self.get_header(request)\n        if header is None:\n            return None\n        \n        raw_token = self.get_raw_token(header)\n        if raw_token is None:\n            return None\n        \n        validated_token = self.get_validated_token(raw_token)\n        return self.get_user(validated_token), validated_token\n\n# API key authentication\nclass APIKeyAuthentication(BaseAuthentication):\n    def authenticate(self, request):\n        api_key = request.META.get('HTTP_X_API_KEY')\n        if not api_key:\n            return None\n        \n        try:\n            user = User.objects.get(profile__api_key=api_key)\n            return (user, None)\n        except User.DoesNotExist:\n            return None",
          followUp: "How would you implement refresh token rotation for enhanced security?"
        },
        {
          id: "security_6",
          question: "What are common security vulnerabilities in Django and how do you prevent them?",
          answer: "Common Django security vulnerabilities:\n\n• SQL Injection: Use parameterized queries\n• Cross-Site Scripting (XSS): Template auto-escaping\n• Cross-Site Request Forgery (CSRF): CSRF middleware\n• Clickjacking: X-Frame-Options header\n• Insecure Direct Object References: Permission checks\n• Security Misconfiguration: Proper settings\n• Sensitive Data Exposure: Encryption and secure storage\n• Broken Authentication: Strong password policies\n• Session Management: Secure session configuration\n• Insufficient Logging: Comprehensive audit trails\n\nPrevention strategies:\n• Input validation and sanitization\n• Output encoding\n• Principle of least privilege\n• Regular security audits\n• Security testing\n• Keep dependencies updated\n• Use security headers\n• Implement proper error handling",
          difficulty: "expert",
          tags: ["vulnerabilities", "security", "prevention"],
          codeExample: "# Preventing SQL injection\n# Bad\nquery = f\"SELECT * FROM users WHERE username = '{username}'\"\n\n# Good\nusers = User.objects.filter(username=username)\n\n# Preventing XSS\n# In template - Django auto-escapes by default\n# {{ user_input }}  # Automatically escaped\n# {{ user_input|safe }}  # Only if you trust the input\n\n# Preventing CSRF\n# In settings.py\nMIDDLEWARE = [\n    'django.middleware.csrf.CsrfViewMiddleware',\n    # ... other middleware\n]\n\n# Preventing clickjacking\nX_FRAME_OPTIONS = 'DENY'\n\n# Secure session configuration\nSESSION_COOKIE_SECURE = True\nSESSION_COOKIE_HTTPONLY = True\nSESSION_COOKIE_SAMESITE = 'Strict'\nSESSION_EXPIRE_AT_BROWSER_CLOSE = True\n\n# Input validation\nfrom django.core.validators import validate_email, RegexValidator\n\nclass UserForm(forms.Form):\n    email = forms.EmailField(validators=[validate_email])\n    phone = forms.CharField(\n        validators=[RegexValidator(r'^\\+?1?\\d{9,15}$', 'Invalid phone number')]\n    )\n    \n    def clean_email(self):\n        email = self.cleaned_data['email']\n        if User.objects.filter(email=email).exists():\n            raise forms.ValidationError('Email already exists')\n        return email",
          followUp: "How would you implement a Web Application Firewall (WAF) in Django?"
        },
        {
          id: "security_7",
          question: "How do you implement secure session management in Django?",
          answer: "Django session security:\n\n• Session middleware configuration\n• Secure session cookies\n• Session timeout and expiration\n• Session invalidation on logout\n• Session fixation protection\n• Cross-site request forgery protection\n• Session storage backends\n\nSecurity settings:\n• SESSION_COOKIE_SECURE: HTTPS only\n• SESSION_COOKIE_HTTPONLY: No JavaScript access\n• SESSION_COOKIE_SAMESITE: CSRF protection\n• SESSION_EXPIRE_AT_BROWSER_CLOSE: Session lifetime\n• SESSION_COOKIE_AGE: Session duration\n• SESSION_SAVE_EVERY_REQUEST: Update expiration\n\nBest practices:\n• Regenerate session ID on login\n• Clear sessions on logout\n• Monitor session activity\n• Implement concurrent session limits\n• Use secure session storage\n• Regular session cleanup",
          difficulty: "advanced",
          tags: ["sessions", "security", "cookies"],
          codeExample: "# Secure session settings\nSESSION_COOKIE_SECURE = True  # HTTPS only\nSESSION_COOKIE_HTTPONLY = True  # No JavaScript access\nSESSION_COOKIE_SAMESITE = 'Strict'  # CSRF protection\nSESSION_EXPIRE_AT_BROWSER_CLOSE = True\nSESSION_COOKIE_AGE = 3600  # 1 hour\nSESSION_SAVE_EVERY_REQUEST = True\n\n# Custom session management\nclass SecureSessionMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n    \n    def __call__(self, request):\n        # Check session validity\n        if request.user.is_authenticated:\n            last_activity = request.session.get('last_activity')\n            if last_activity:\n                time_since_activity = timezone.now() - datetime.fromisoformat(last_activity)\n                if time_since_activity > timedelta(minutes=30):\n                    # Session timeout\n                    request.session.flush()\n                    messages.warning(request, 'Your session has expired')\n                    return redirect('login')\n            \n            # Update last activity\n            request.session['last_activity'] = timezone.now().isoformat()\n        \n        response = self.get_response(request)\n        return response\n\n# Session regeneration on login\nfrom django.contrib.auth import login\n\ndef custom_login(request):\n    if request.method == 'POST':\n        form = AuthenticationForm(request, data=request.POST)\n        if form.is_valid():\n            user = form.get_user()\n            # Regenerate session\n            request.session.cycle_key()\n            login(request, user)\n            return redirect('dashboard')\n    else:\n        form = AuthenticationForm()\n    return render(request, 'login.html', {'form': form})",
          followUp: "How would you implement session-based user activity tracking?"
        },
        {
          id: "security_8",
          question: "How do you implement audit logging and security monitoring in Django?",
          answer: "Django security monitoring:\n\n• Authentication events logging\n• Permission changes tracking\n• Data access logging\n• Failed login attempts\n• Administrative actions audit\n• Security-related exceptions\n• User activity monitoring\n\nImplementation strategies:\n• Django logging framework\n• Database audit tables\n• File-based logging\n• External logging services\n• Real-time monitoring\n• Alerting and notifications\n• Log aggregation and analysis\n\nBest practices:\n• Log all security-relevant events\n• Include contextual information\n• Protect log data integrity\n• Regular log review and analysis\n• Implement log retention policies\n• Use structured logging formats\n• Monitor for suspicious patterns",
          difficulty: "advanced",
          tags: ["audit-logging", "monitoring", "security"],
          codeExample: "# Custom audit logging\nimport logging\nfrom django.db.models.signals import post_save, post_delete\nfrom django.dispatch import receiver\n\n# Configure security logger\nsecurity_logger = logging.getLogger('security')\n\n# Audit model\nclass AuditLog(models.Model):\n    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)\n    action = models.CharField(max_length=50)\n    model_name = models.CharField(max_length=100)\n    object_id = models.CharField(max_length=100)\n    changes = models.JSONField(default=dict)\n    ip_address = models.GenericIPAddressField(null=True)\n    timestamp = models.DateTimeField(auto_now_add=True)\n    \n    class Meta:\n        ordering = ['-timestamp']\n\n# Audit middleware\nclass AuditMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n    \n    def __call__(self, request):\n        # Store request info for audit logging\n        request.audit_info = {\n            'ip_address': self.get_client_ip(request),\n            'user_agent': request.META.get('HTTP_USER_AGENT', ''),\n            'timestamp': timezone.now()\n        }\n        \n        response = self.get_response(request)\n        return response\n    \n    def get_client_ip(self, request):\n        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')\n        if x_forwarded_for:\n            ip = x_forwarded_for.split(',')[0]\n        else:\n            ip = request.META.get('REMOTE_ADDR')\n        return ip\n\n# Signal-based audit logging\n@receiver(post_save)\ndef audit_model_save(sender, instance, created, **kwargs):\n    if hasattr(instance, '_audit_user'):\n        AuditLog.objects.create(\n            user=instance._audit_user,\n            action='create' if created else 'update',\n            model_name=sender.__name__,\n            object_id=str(instance.pk),\n            changes=instance._audit_changes if hasattr(instance, '_audit_changes') else {},\n            ip_address=instance._audit_ip if hasattr(instance, '_audit_ip') else None\n        )\n\n# Failed login tracking\nfrom django.contrib.auth.signals import user_login_failed\n\n@receiver(user_login_failed)\ndef log_failed_login(sender, credentials, request, **kwargs):\n    security_logger.warning(\n        'Failed login attempt',\n        extra={\n            'username': credentials.get('username'),\n            'ip_address': request.META.get('REMOTE_ADDR'),\n            'user_agent': request.META.get('HTTP_USER_AGENT')\n        }\n    )",
          followUp: "How would you implement real-time security alerting for suspicious activities?"
        }
      ]
    },
    {
      title: "Forms & Validation",
      icon: "code",
      story: {
        title: "Form Validation Nightmare",
        content: "The customer support team is overwhelmed with complaints about form submissions. Users are getting confusing error messages, and some malicious data is getting through. The head of customer success pulls Alex into a meeting: 'We need bulletproof forms that provide clear feedback and prevent any security issues. Can you redesign our form validation system?'",
        context: "This section covers Django forms, validation, widgets, and form security."
      },
      questions: [
        {
          id: "form_1",
          question: "Explain Django forms vs ModelForms and when to use each.",
          answer: "Django Forms vs ModelForms:\n\nDjango Forms:\n• Manual field definition\n• Full control over fields and validation\n• Not tied to models\n• Good for custom forms\n• Suitable for forms that don't map to models\n\nModelForms:\n• Automatically generated from models\n• Less boilerplate code\n• Automatic field types and validation\n• Built-in save() method\n• Good for CRUD operations\n• Easier to maintain\n\nWhen to use Forms:\n• Contact forms\n• Search forms\n• Login forms\n• Forms spanning multiple models\n• Forms with custom logic\n\nWhen to use ModelForms:\n• Creating/editing model instances\n• CRUD operations\n• Admin-like interfaces\n• Rapid prototyping",
          difficulty: "intermediate",
          tags: ["forms", "modelforms", "validation"],
          codeExample: "# Django Form\nclass ContactForm(forms.Form):\n    name = forms.CharField(max_length=100)\n    email = forms.EmailField()\n    message = forms.CharField(widget=forms.Textarea)\n    \n    def clean_email(self):\n        email = self.cleaned_data['email']\n        if not email.endswith('@company.com'):\n            raise forms.ValidationError('Must use company email')\n        return email\n\n# ModelForm\nclass BookForm(forms.ModelForm):\n    class Meta:\n        model = Book\n        fields = ['title', 'author', 'isbn', 'publication_date']\n        widgets = {\n            'publication_date': forms.DateInput(attrs={'type': 'date'}),\n            'title': forms.TextInput(attrs={'placeholder': 'Enter book title'})\n        }\n    \n    def clean_isbn(self):\n        isbn = self.cleaned_data['isbn']\n        if Book.objects.filter(isbn=isbn).exists():\n            raise forms.ValidationError('Book with this ISBN already exists')\n        return isbn",
          followUp: "How would you create a form that updates multiple related models?"
        },
        {
          id: "form_2",
          question: "How do you implement custom validation in Django forms?",
          answer: "Django custom validation levels:\n\n• Field-level validation: clean_<fieldname>()\n• Form-level validation: clean()\n• Cross-field validation: clean()\n• Custom validators: Reusable functions\n• Model validation: clean() method\n• Database constraints: Unique constraints\n\nValidation order:\n1. Field validators\n2. Field clean methods\n3. Form clean method\n4. Model validation (if ModelForm)\n5. Database constraints\n\nBest practices:\n• Validate early and often\n• Provide clear error messages\n• Use appropriate validation levels\n• Handle edge cases\n• Test validation thoroughly\n• Consider security implications",
          difficulty: "intermediate",
          tags: ["validation", "forms", "security"],
          codeExample: "# Custom validators\nfrom django.core.validators import RegexValidator\n\ndef validate_phone_number(value):\n    if not value.startswith('+'):\n        raise ValidationError('Phone number must start with country code')\n    if len(value) < 10:\n        raise ValidationError('Phone number too short')\n\nclass UserRegistrationForm(forms.Form):\n    username = forms.CharField(\n        max_length=30,\n        validators=[RegexValidator(r'^[a-zA-Z0-9_]+$', 'Username can only contain letters, numbers, and underscores')]\n    )\n    email = forms.EmailField()\n    phone = forms.CharField(validators=[validate_phone_number])\n    password = forms.CharField(widget=forms.PasswordInput, min_length=8)\n    password_confirm = forms.CharField(widget=forms.PasswordInput)\n    \n    def clean_username(self):\n        username = self.cleaned_data['username']\n        if User.objects.filter(username=username).exists():\n            raise forms.ValidationError('Username already exists')\n        return username\n    \n    def clean_email(self):\n        email = self.cleaned_data['email']\n        if User.objects.filter(email=email).exists():\n            raise forms.ValidationError('Email already registered')\n        return email\n    \n    def clean(self):\n        cleaned_data = super().clean()\n        password = cleaned_data.get('password')\n        password_confirm = cleaned_data.get('password_confirm')\n        \n        if password and password_confirm and password != password_confirm:\n            raise forms.ValidationError('Passwords do not match')\n        \n        return cleaned_data",
          followUp: "How would you implement async validation for checking username availability?"
        },
        {
          id: "form_3",
          question: "Explain Django form widgets and how to create custom widgets.",
          answer: "Django form widgets:\n\n• Control HTML representation of fields\n• Handle rendering and value extraction\n• Built-in widgets for common inputs\n• Custom widgets for specialized needs\n• Media handling (CSS/JS)\n• Widget inheritance and composition\n\nBuilt-in widgets:\n• TextInput, NumberInput, EmailInput\n• Textarea, Select, CheckboxInput\n• DateInput, TimeInput, DateTimeInput\n• FileInput, ImageInput\n• HiddenInput, MultipleHiddenInput\n\nCustom widgets:\n• Override render() method\n• Handle value_from_datadict()\n• Add media for CSS/JS\n• Compound widgets\n• JavaScript integration",
          difficulty: "advanced",
          tags: ["widgets", "forms", "frontend"],
          codeExample: "# Custom widget\nclass ColorPickerWidget(forms.TextInput):\n    template_name = 'widgets/color_picker.html'\n    \n    def __init__(self, attrs=None):\n        default_attrs = {'class': 'color-picker'}\n        if attrs:\n            default_attrs.update(attrs)\n        super().__init__(default_attrs)\n    \n    class Media:\n        css = {\n            'all': ('css/color-picker.css',)\n        }\n        js = ('js/color-picker.js',)\n\n# Multi-widget for date/time\nclass DateTimePickerWidget(forms.MultiWidget):\n    template_name = 'widgets/datetime_picker.html'\n    \n    def __init__(self, attrs=None):\n        widgets = [\n            forms.DateInput(attrs={'type': 'date'}),\n            forms.TimeInput(attrs={'type': 'time'})\n        ]\n        super().__init__(widgets, attrs)\n    \n    def decompress(self, value):\n        if value:\n            return [value.date(), value.time()]\n        return [None, None]\n    \n    def value_from_datadict(self, data, files, name):\n        date_str = data.get(name + '_0')\n        time_str = data.get(name + '_1')\n        \n        if date_str and time_str:\n            return datetime.combine(\n                datetime.strptime(date_str, '%Y-%m-%d').date(),\n                datetime.strptime(time_str, '%H:%M').time()\n            )\n        return None\n\n# Using custom widget\nclass EventForm(forms.Form):\n    name = forms.CharField(max_length=100)\n    color = forms.CharField(widget=ColorPickerWidget)\n    start_time = forms.DateTimeField(widget=DateTimePickerWidget)",
          followUp: "How would you create a widget for handling multiple file uploads with preview?"
        },
        {
          id: "form_4",
          question: "How do you handle formsets and inline forms in Django?",
          answer: "Django formsets:\n\n• Handle multiple forms together\n• Form validation across multiple instances\n• Dynamic form addition/removal\n• Inline formsets for related models\n• Formset validation and errors\n• Custom formset classes\n\nTypes of formsets:\n• BaseFormSet: Generic formset\n• ModelFormSet: For model instances\n• InlineFormSet: For related models\n• Custom formsets: Specialized behavior\n\nKey features:\n• can_delete: Allow deletion\n• extra: Number of empty forms\n• max_num: Maximum forms\n• min_num: Minimum forms\n• validate_max/min: Validation\n• Management form: Hidden fields",
          difficulty: "advanced",
          tags: ["formsets", "inline-forms", "models"],
          codeExample: "# Basic formset\nfrom django.forms import formset_factory\n\nContactFormSet = formset_factory(\n    ContactForm,\n    extra=2,\n    max_num=5,\n    can_delete=True\n)\n\n# Model formset\nfrom django.forms import modelformset_factory\n\nBookFormSet = modelformset_factory(\n    Book,\n    fields=['title', 'author', 'isbn'],\n    extra=1,\n    can_delete=True\n)\n\n# Inline formset\nfrom django.forms import inlineformset_factory\n\nBookInlineFormSet = inlineformset_factory(\n    Author,\n    Book,\n    fields=['title', 'isbn', 'publication_date'],\n    extra=1,\n    can_delete=True\n)\n\n# Custom formset validation\nclass BaseBookFormSet(BaseModelFormSet):\n    def clean(self):\n        if any(self.errors):\n            return\n        \n        isbns = []\n        for form in self.forms:\n            if form.cleaned_data and not form.cleaned_data.get('DELETE'):\n                isbn = form.cleaned_data.get('isbn')\n                if isbn in isbns:\n                    raise forms.ValidationError('Duplicate ISBN numbers')\n                isbns.append(isbn)\n\n# View handling\ndef manage_books(request, author_id):\n    author = get_object_or_404(Author, id=author_id)\n    BookFormSet = inlineformset_factory(\n        Author, Book, \n        form=BookForm, \n        formset=BaseBookFormSet,\n        extra=1\n    )\n    \n    if request.method == 'POST':\n        formset = BookFormSet(request.POST, instance=author)\n        if formset.is_valid():\n            formset.save()\n            return redirect('author_detail', author_id=author.id)\n    else:\n        formset = BookFormSet(instance=author)\n    \n    return render(request, 'manage_books.html', {\n        'author': author,\n        'formset': formset\n    })",
          followUp: "How would you implement dynamic formset addition/removal with JavaScript?"
        },
        {
          id: "form_5",
          question: "How do you implement AJAX form submission and validation in Django?",
          answer: "AJAX form handling in Django:\n\n• JSON responses for form validation\n• Partial template updates\n• Client-side form validation\n• Progressive enhancement\n• Error handling and display\n• File upload handling\n• CSRF token management\n\nImplementation strategies:\n• Return JSON for AJAX requests\n• Use form.errors for validation feedback\n• Handle both AJAX and regular submissions\n• Implement proper error handling\n• Use JavaScript libraries (jQuery, fetch)\n• Progressive enhancement approach\n• Graceful fallbacks",
          difficulty: "advanced",
          tags: ["ajax", "forms", "javascript"],
          codeExample: "# AJAX form view\nfrom django.http import JsonResponse\nfrom django.template.loader import render_to_string\n\ndef ajax_contact_form(request):\n    if request.method == 'POST':\n        form = ContactForm(request.POST)\n        if form.is_valid():\n            # Process form data\n            contact = form.save()\n            \n            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':\n                return JsonResponse({\n                    'success': True,\n                    'message': 'Contact form submitted successfully',\n                    'redirect_url': reverse('contact_success')\n                })\n            else:\n                return redirect('contact_success')\n        else:\n            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':\n                return JsonResponse({\n                    'success': False,\n                    'errors': form.errors,\n                    'form_html': render_to_string('forms/contact_form.html', {\n                        'form': form\n                    }, request=request)\n                })\n    else:\n        form = ContactForm()\n    \n    return render(request, 'contact.html', {'form': form})\n\n# JavaScript (using fetch)\nfunction submitForm(form) {\n    const formData = new FormData(form);\n    \n    fetch(form.action, {\n        method: 'POST',\n        body: formData,\n        headers: {\n            'X-Requested-With': 'XMLHttpRequest',\n            'X-CSRFToken': getCookie('csrftoken')\n        }\n    })\n    .then(response => response.json())\n    .then(data => {\n        if (data.success) {\n            showMessage(data.message, 'success');\n            if (data.redirect_url) {\n                window.location.href = data.redirect_url;\n            }\n        } else {\n            displayErrors(data.errors);\n            if (data.form_html) {\n                document.getElementById('form-container').innerHTML = data.form_html;\n            }\n        }\n    })\n    .catch(error => {\n        console.error('Error:', error);\n        showMessage('An error occurred. Please try again.', 'error');\n    });\n}\n\n// CSRF token helper\nfunction getCookie(name) {\n    let cookieValue = null;\n    if (document.cookie && document.cookie !== '') {\n        const cookies = document.cookie.split(';');\n        for (let i = 0; i < cookies.length; i++) {\n            const cookie = cookies[i].trim();\n            if (cookie.substring(0, name.length + 1) === (name + '=')) {\n                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n                break;\n            }\n        }\n    }\n    return cookieValue;\n}",
          followUp: "How would you implement real-time form validation as the user types?"
        },
        {
          id: "form_6",
          question: "How do you handle file uploads and image processing in Django forms?",
          answer: "Django file upload handling:\n\n• FileField and ImageField in forms\n• File validation (size, type, content)\n• Custom upload paths\n• Image processing and thumbnails\n• Multiple file uploads\n• Progress tracking\n• Security considerations\n\nKey components:\n• request.FILES for uploaded files\n• Storage backends for file handling\n• Validators for file validation\n• Pillow for image processing\n• Custom widgets for file uploads\n• AJAX for better UX\n\nSecurity best practices:\n• Validate file types and content\n• Limit file sizes\n• Sanitize file names\n• Store files outside web root\n• Scan for malware\n• Use secure storage services",
          difficulty: "intermediate",
          tags: ["file-uploads", "images", "security"],
          codeExample: "# File upload form\nfrom django.core.validators import FileExtensionValidator\n\ndef validate_image_size(image):\n    max_size = 5 * 1024 * 1024  # 5MB\n    if image.size > max_size:\n        raise ValidationError('Image file too large (max 5MB)')\n\nclass DocumentForm(forms.Form):\n    title = forms.CharField(max_length=200)\n    document = forms.FileField(\n        validators=[\n            FileExtensionValidator(allowed_extensions=['pdf', 'doc', 'docx']),\n        ]\n    )\n    image = forms.ImageField(\n        validators=[validate_image_size],\n        required=False\n    )\n    \n    def clean_document(self):\n        document = self.cleaned_data['document']\n        if document:\n            # Additional validation\n            if document.content_type not in ['application/pdf', 'application/msword']:\n                raise forms.ValidationError('Invalid file type')\n        return document\n\n# Model with file handling\nclass Document(models.Model):\n    title = models.CharField(max_length=200)\n    document = models.FileField(\n        upload_to='documents/%Y/%m/%d/',\n        validators=[FileExtensionValidator(allowed_extensions=['pdf', 'doc'])]\n    )\n    thumbnail = models.ImageField(\n        upload_to='thumbnails/',\n        blank=True,\n        null=True\n    )\n    \n    def save(self, *args, **kwargs):\n        super().save(*args, **kwargs)\n        \n        # Generate thumbnail if image\n        if self.document and self.document.name.lower().endswith(('.png', '.jpg', '.jpeg')):\n            self.generate_thumbnail()\n    \n    def generate_thumbnail(self):\n        from PIL import Image\n        from io import BytesIO\n        from django.core.files.base import ContentFile\n        \n        image = Image.open(self.document)\n        image.thumbnail((200, 200))\n        \n        thumb_io = BytesIO()\n        image.save(thumb_io, format='JPEG', quality=85)\n        thumb_file = ContentFile(thumb_io.getvalue())\n        \n        self.thumbnail.save(\n            f'thumb_{self.document.name}',\n            thumb_file,\n            save=False\n        )\n        self.save()\n\n# Multiple file upload widget\nclass MultipleFileInput(forms.ClearableFileInput):\n    allow_multiple_selected = True\n    \n    def value_from_datadict(self, data, files, name):\n        upload = files.getlist(name)\n        if not upload:\n            return None\n        return upload\n\nclass MultipleFileField(forms.FileField):\n    widget = MultipleFileInput\n    \n    def to_python(self, data):\n        if isinstance(data, list):\n            return [super().to_python(f) for f in data]\n        return super().to_python(data)",
          followUp: "How would you implement chunked file upload for large files?"
        },
        {
          id: "form_7",
          question: "How do you implement dynamic forms that change based on user input?",
          answer: "Dynamic Django forms:\n\n• Conditional field display\n• Field choices based on other fields\n• Form field addition/removal\n• Cascading dropdowns\n• Progressive disclosure\n• Client-side and server-side approaches\n\nImplementation strategies:\n• Override __init__ method\n• Use JavaScript for immediate feedback\n• AJAX for server-side logic\n• Form wizard for multi-step forms\n• Conditional validation\n• Dynamic field generation\n\nBest practices:\n• Progressive enhancement\n• Graceful fallbacks\n• Clear user feedback\n• Maintain form state\n• Handle edge cases\n• Test thoroughly",
          difficulty: "advanced",
          tags: ["dynamic-forms", "javascript", "conditional"],
          codeExample: "# Dynamic form based on user input\nclass DynamicOrderForm(forms.Form):\n    customer_type = forms.ChoiceField(\n        choices=[('individual', 'Individual'), ('business', 'Business')],\n        widget=forms.RadioSelect\n    )\n    \n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        \n        # Add fields based on customer type\n        if self.data.get('customer_type') == 'business':\n            self.fields['company_name'] = forms.CharField(\n                max_length=200,\n                required=True\n            )\n            self.fields['tax_id'] = forms.CharField(\n                max_length=50,\n                required=True\n            )\n            self.fields['billing_contact'] = forms.CharField(\n                max_length=200\n            )\n        else:\n            self.fields['first_name'] = forms.CharField(max_length=100)\n            self.fields['last_name'] = forms.CharField(max_length=100)\n\n# Cascading dropdown example\nclass LocationForm(forms.Form):\n    country = forms.ModelChoiceField(\n        queryset=Country.objects.all(),\n        empty_label='Select Country'\n    )\n    state = forms.ModelChoiceField(\n        queryset=State.objects.none(),\n        empty_label='Select State',\n        required=False\n    )\n    city = forms.ModelChoiceField(\n        queryset=City.objects.none(),\n        empty_label='Select City',\n        required=False\n    )\n    \n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        \n        if 'country' in self.data:\n            try:\n                country_id = int(self.data.get('country'))\n                self.fields['state'].queryset = State.objects.filter(country_id=country_id)\n            except (ValueError, TypeError):\n                pass\n        \n        if 'state' in self.data:\n            try:\n                state_id = int(self.data.get('state'))\n                self.fields['city'].queryset = City.objects.filter(state_id=state_id)\n            except (ValueError, TypeError):\n                pass\n\n# AJAX view for dynamic field loading\ndef load_states(request):\n    country_id = request.GET.get('country')\n    states = State.objects.filter(country_id=country_id)\n    return JsonResponse({\n        'states': [{'id': s.id, 'name': s.name} for s in states]\n    })\n\n# JavaScript for dynamic updates\nfunction updateFormFields() {\n    const customerType = document.querySelector('input[name=\"customer_type\"]:checked').value;\n    const dynamicFields = document.getElementById('dynamic-fields');\n    \n    fetch('/get-form-fields/', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'X-CSRFToken': getCookie('csrftoken')\n        },\n        body: `customer_type=${customerType}`\n    })\n    .then(response => response.json())\n    .then(data => {\n        dynamicFields.innerHTML = data.fields_html;\n    });\n}",
          followUp: "How would you implement a form wizard with conditional steps?"
        },
        {
          id: "form_8",
          question: "How do you implement form security and prevent common attacks?",
          answer: "Django form security measures:\n\n• CSRF protection for all forms\n• Input validation and sanitization\n• File upload security\n• SQL injection prevention\n• XSS protection\n• Rate limiting\n• Honeypot fields\n• Captcha integration\n\nSecurity best practices:\n• Validate all user input\n• Use Django's built-in protection\n• Implement proper error handling\n• Don't trust client-side validation\n• Use HTTPS for sensitive forms\n• Implement proper authentication\n• Log security events\n• Regular security audits\n\nCommon attack vectors:\n• Cross-site scripting (XSS)\n• SQL injection\n• CSRF attacks\n• File upload vulnerabilities\n• Mass assignment\n• Timing attacks\n• Brute force attacks",
          difficulty: "expert",
          tags: ["security", "csrf", "validation"],
          codeExample: "# Secure form implementation\nfrom django.middleware.csrf import get_token\nfrom django.contrib.auth.decorators import login_required\nfrom django.views.decorators.http import require_POST\nfrom django.utils.html import escape\n\nclass SecureContactForm(forms.Form):\n    name = forms.CharField(\n        max_length=100,\n        validators=[RegexValidator(r'^[a-zA-Z\\s]+$', 'Name can only contain letters and spaces')]\n    )\n    email = forms.EmailField()\n    subject = forms.CharField(max_length=200)\n    message = forms.CharField(\n        widget=forms.Textarea,\n        max_length=1000\n    )\n    \n    # Honeypot field (hidden from users)\n    honeypot = forms.CharField(\n        required=False,\n        widget=forms.HiddenInput\n    )\n    \n    def clean_honeypot(self):\n        honeypot = self.cleaned_data.get('honeypot')\n        if honeypot:\n            # Bot detected\n            raise forms.ValidationError('Form submission rejected')\n        return honeypot\n    \n    def clean_message(self):\n        message = self.cleaned_data.get('message')\n        if message:\n            # Basic XSS prevention (Django handles this automatically)\n            message = escape(message)\n            \n            # Check for spam patterns\n            spam_keywords = ['viagra', 'casino', 'lottery']\n            if any(keyword in message.lower() for keyword in spam_keywords):\n                raise forms.ValidationError('Message contains prohibited content')\n        \n        return message\n\n# Rate limiting decorator\nfrom django.core.cache import cache\nfrom django.http import HttpResponseTooManyRequests\n\ndef rate_limit(max_requests=5, window=300):  # 5 requests per 5 minutes\n    def decorator(view_func):\n        def wrapper(request, *args, **kwargs):\n            client_ip = request.META.get('REMOTE_ADDR')\n            cache_key = f'rate_limit_{client_ip}_{view_func.__name__}'\n            \n            requests = cache.get(cache_key, 0)\n            if requests >= max_requests:\n                return HttpResponseTooManyRequests('Too many requests')\n            \n            cache.set(cache_key, requests + 1, window)\n            return view_func(request, *args, **kwargs)\n        return wrapper\n    return decorator\n\n# Secure form view\n@login_required\n@require_POST\n@rate_limit(max_requests=3, window=300)\ndef secure_contact_view(request):\n    # Verify CSRF token\n    if not request.META.get('HTTP_X_CSRFTOKEN'):\n        return HttpResponseForbidden('CSRF token missing')\n    \n    form = SecureContactForm(request.POST)\n    if form.is_valid():\n        # Process form securely\n        contact_data = {\n            'name': form.cleaned_data['name'],\n            'email': form.cleaned_data['email'],\n            'subject': form.cleaned_data['subject'],\n            'message': form.cleaned_data['message'],\n            'user': request.user,\n            'ip_address': request.META.get('REMOTE_ADDR'),\n            'user_agent': request.META.get('HTTP_USER_AGENT')\n        }\n        \n        # Log form submission\n        logger.info(f'Contact form submitted by {request.user.username} from {request.META.get(\"REMOTE_ADDR\")}')\n        \n        # Save to database\n        contact = Contact.objects.create(**contact_data)\n        \n        return JsonResponse({'success': True, 'message': 'Form submitted successfully'})\n    else:\n        return JsonResponse({'success': False, 'errors': form.errors})\n\n# File upload security\nclass SecureFileUploadForm(forms.Form):\n    file = forms.FileField(\n        validators=[\n            FileExtensionValidator(allowed_extensions=['pdf', 'jpg', 'png']),\n        ]\n    )\n    \n    def clean_file(self):\n        file = self.cleaned_data.get('file')\n        if file:\n            # Check file size\n            if file.size > 5 * 1024 * 1024:  # 5MB\n                raise forms.ValidationError('File too large')\n            \n            # Check file content type\n            allowed_types = ['application/pdf', 'image/jpeg', 'image/png']\n            if file.content_type not in allowed_types:\n                raise forms.ValidationError('Invalid file type')\n            \n            # Scan file content (basic check)\n            file.seek(0)\n            content = file.read(1024)\n            if b'<script' in content.lower():\n                raise forms.ValidationError('Potentially malicious file')\n            file.seek(0)\n        \n        return file",
          followUp: "How would you implement advanced bot detection and prevention?"
        }
      ]
    },
    {
      title: "Testing & Debugging",
      icon: "zap",
      story: {
        title: "The Testing Crisis",
        content: "The QA team reports that the latest release broke several features that were supposedly working. The CTO calls an emergency meeting: 'We need a comprehensive testing strategy that catches issues before they reach production. Alex, I need you to implement a robust testing framework that covers unit tests, integration tests, and performance testing.'",
        context: "This section covers Django testing, debugging techniques, and quality assurance practices."
      },
      questions: [
        {
          id: "test_1",
          question: "Explain Django's testing framework and different types of tests you should write.",
          answer: "Django testing framework:\n\n• Built on Python's unittest framework\n• TestCase class for database tests\n• TransactionTestCase for transaction testing\n• LiveServerTestCase for Selenium tests\n• SimpleTestCase for non-database tests\n• Test client for HTTP requests\n• Test database isolation\n• Fixtures for test data\n\nTypes of tests:\n• Unit tests: Individual functions/methods\n• Integration tests: Multiple components\n• Functional tests: End-to-end workflows\n• Performance tests: Load and stress testing\n• Security tests: Vulnerability testing\n• API tests: REST/GraphQL endpoints\n• Browser tests: Selenium automation\n• Database tests: Model and query testing",
          difficulty: "intermediate",
          tags: ["testing", "unittest", "framework"],
          codeExample: "# Model tests\nfrom django.test import TestCase\nfrom django.core.exceptions import ValidationError\nfrom .models import Book, Author\n\nclass BookModelTest(TestCase):\n    def setUp(self):\n        self.author = Author.objects.create(\n            name='Test Author',\n            email='test@example.com'\n        )\n    \n    def test_book_creation(self):\n        book = Book.objects.create(\n            title='Test Book',\n            author=self.author,\n            isbn='1234567890123'\n        )\n        self.assertEqual(book.title, 'Test Book')\n        self.assertEqual(book.author, self.author)\n        self.assertTrue(book.created_at)\n    \n    def test_book_str_representation(self):\n        book = Book(title='Test Book', author=self.author)\n        self.assertEqual(str(book), 'Test Book')\n    \n    def test_isbn_validation(self):\n        book = Book(\n            title='Test Book',\n            author=self.author,\n            isbn='invalid-isbn'\n        )\n        with self.assertRaises(ValidationError):\n            book.full_clean()\n\n# View tests\nclass BookViewTest(TestCase):\n    def setUp(self):\n        self.author = Author.objects.create(\n            name='Test Author',\n            email='test@example.com'\n        )\n        self.book = Book.objects.create(\n            title='Test Book',\n            author=self.author,\n            isbn='1234567890123'\n        )\n    \n    def test_book_list_view(self):\n        response = self.client.get('/books/')\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, 'Test Book')\n        self.assertContains(response, 'Test Author')\n    \n    def test_book_detail_view(self):\n        response = self.client.get(f'/books/{self.book.pk}/')\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.context['book'], self.book)\n    \n    def test_book_create_view(self):\n        response = self.client.post('/books/create/', {\n            'title': 'New Book',\n            'author': self.author.pk,\n            'isbn': '9876543210987'\n        })\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(Book.objects.filter(title='New Book').exists())",
          followUp: "How would you implement property-based testing for Django models?"
        },
        {
          id: "test_2",
          question: "How do you test Django views, forms, and models effectively?",
          answer: "Testing Django components:\n\nModel testing:\n• Field validation and constraints\n• Model methods and properties\n• Model relationships\n• Custom managers and querysets\n• Signal handlers\n• Model inheritance\n\nView testing:\n• HTTP status codes\n• Template rendering\n• Context data\n• Redirects and URL reversing\n• Authentication and permissions\n• Form processing\n• AJAX responses\n\nForm testing:\n• Field validation\n• Form-level validation\n• Form rendering\n• Widget functionality\n• File upload handling\n• Formset behavior\n\nBest practices:\n• Test both success and failure cases\n• Use meaningful test names\n• Keep tests isolated and independent\n• Use factories for test data\n• Mock external dependencies\n• Test edge cases and boundary conditions",
          difficulty: "intermediate",
          tags: ["testing", "views", "forms", "models"],
          codeExample: "# Form testing\nclass ContactFormTest(TestCase):\n    def test_valid_form(self):\n        form_data = {\n            'name': 'John Doe',\n            'email': 'john@example.com',\n            'message': 'Test message'\n        }\n        form = ContactForm(data=form_data)\n        self.assertTrue(form.is_valid())\n    \n    def test_form_save(self):\n        form_data = {\n            'name': 'John Doe',\n            'email': 'john@example.com',\n            'message': 'Test message'\n        }\n        form = ContactForm(data=form_data)\n        self.assertTrue(form.is_valid())\n        contact = form.save()\n        self.assertEqual(contact.name, 'John Doe')\n        self.assertEqual(contact.email, 'john@example.com')\n    \n    def test_invalid_email(self):\n        form_data = {\n            'name': 'John Doe',\n            'email': 'invalid-email',\n            'message': 'Test message'\n        }\n        form = ContactForm(data=form_data)\n        self.assertFalse(form.is_valid())\n        self.assertIn('email', form.errors)\n    \n    def test_required_fields(self):\n        form = ContactForm(data={})\n        self.assertFalse(form.is_valid())\n        self.assertIn('name', form.errors)\n        self.assertIn('email', form.errors)\n        self.assertIn('message', form.errors)\n\n# Advanced view testing with authentication\nclass ProtectedViewTest(TestCase):\n    def setUp(self):\n        self.user = User.objects.create_user(\n            username='testuser',\n            email='test@example.com',\n            password='testpass123'\n        )\n        self.staff_user = User.objects.create_user(\n            username='staffuser',\n            email='staff@example.com',\n            password='staffpass123',\n            is_staff=True\n        )\n    \n    def test_login_required(self):\n        response = self.client.get('/protected-view/')\n        self.assertEqual(response.status_code, 302)\n        self.assertRedirects(response, '/accounts/login/?next=/protected-view/')\n    \n    def test_staff_required(self):\n        self.client.login(username='testuser', password='testpass123')\n        response = self.client.get('/admin-view/')\n        self.assertEqual(response.status_code, 403)\n    \n    def test_staff_access(self):\n        self.client.login(username='staffuser', password='staffpass123')\n        response = self.client.get('/admin-view/')\n        self.assertEqual(response.status_code, 200)\n\n# Testing with factories\nimport factory\nfrom django.contrib.auth.models import User\n\nclass UserFactory(factory.django.DjangoModelFactory):\n    class Meta:\n        model = User\n    \n    username = factory.Sequence(lambda n: f'user{n}')\n    email = factory.LazyAttribute(lambda obj: f'{obj.username}@example.com')\n    first_name = factory.Faker('first_name')\n    last_name = factory.Faker('last_name')\n\nclass BookFactory(factory.django.DjangoModelFactory):\n    class Meta:\n        model = Book\n    \n    title = factory.Faker('sentence', nb_words=4)\n    author = factory.SubFactory(UserFactory)\n    isbn = factory.Faker('isbn13')\n    publication_date = factory.Faker('date_this_decade')\n\n# Using factories in tests\nclass BookTestWithFactory(TestCase):\n    def test_book_creation_with_factory(self):\n        book = BookFactory()\n        self.assertIsNotNone(book.pk)\n        self.assertTrue(book.title)\n        self.assertIsNotNone(book.author)\n    \n    def test_multiple_books(self):\n        books = BookFactory.create_batch(5)\n        self.assertEqual(len(books), 5)\n        self.assertEqual(Book.objects.count(), 5)",
          followUp: "How would you implement test data seeding for complex scenarios?"
        },
        {
          id: "test_3",
          question: "How do you implement test fixtures and mock external dependencies?",
          answer: "Django test fixtures and mocking:\n\nTest fixtures:\n• JSON/YAML fixture files\n• Database fixture loading\n• setUp/tearDown methods\n• Class-based fixtures\n• Factories for dynamic data\n• Fixture management commands\n\nMocking strategies:\n• unittest.mock for Python mocking\n• Mock external API calls\n• Mock database queries\n• Mock file system operations\n• Mock email sending\n• Mock celery tasks\n• Mock third-party services\n\nBest practices:\n• Use factories over fixtures\n• Mock at the boundary\n• Test with realistic data\n• Keep fixtures small and focused\n• Use context managers for mocking\n• Patch at the right level\n• Verify mock calls",
          difficulty: "advanced",
          tags: ["fixtures", "mocking", "testing"],
          codeExample: "# Fixture example\n# fixtures/test_data.json\n[\n    {\n        \"model\": \"auth.user\",\n        \"pk\": 1,\n        \"fields\": {\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"first_name\": \"Test\",\n            \"last_name\": \"User\"\n        }\n    },\n    {\n        \"model\": \"books.book\",\n        \"pk\": 1,\n        \"fields\": {\n            \"title\": \"Test Book\",\n            \"author\": 1,\n            \"isbn\": \"1234567890123\"\n        }\n    }\n]\n\n# Using fixtures in tests\nclass BookTestWithFixtures(TestCase):\n    fixtures = ['test_data.json']\n    \n    def test_book_exists(self):\n        book = Book.objects.get(pk=1)\n        self.assertEqual(book.title, 'Test Book')\n\n# Mocking external API calls\nfrom unittest.mock import patch, Mock\nimport requests\n\nclass ExternalAPITest(TestCase):\n    @patch('requests.get')\n    def test_fetch_book_data(self, mock_get):\n        # Mock the API response\n        mock_response = Mock()\n        mock_response.json.return_value = {\n            'title': 'API Book',\n            'author': 'API Author',\n            'isbn': '1234567890'\n        }\n        mock_response.status_code = 200\n        mock_get.return_value = mock_response\n        \n        # Test the function\n        book_data = fetch_book_from_api('1234567890')\n        \n        # Verify the mock was called\n        mock_get.assert_called_once_with('https://api.example.com/books/1234567890')\n        self.assertEqual(book_data['title'], 'API Book')\n    \n    @patch('myapp.services.send_email')\n    def test_book_creation_sends_email(self, mock_send_email):\n        # Create a book\n        book = Book.objects.create(\n            title='New Book',\n            author='New Author',\n            isbn='1234567890'\n        )\n        \n        # Verify email was sent\n        mock_send_email.assert_called_once()\n        call_args = mock_send_email.call_args[0]\n        self.assertIn('New Book', call_args[1])  # Email subject\n\n# Context manager for mocking\nclass EmailTest(TestCase):\n    def test_contact_form_sends_email(self):\n        with patch('django.core.mail.send_mail') as mock_send_mail:\n            # Submit contact form\n            response = self.client.post('/contact/', {\n                'name': 'John Doe',\n                'email': 'john@example.com',\n                'message': 'Test message'\n            })\n            \n            # Verify email was sent\n            self.assertEqual(response.status_code, 302)\n            mock_send_mail.assert_called_once()\n            \n            # Check email content\n            args, kwargs = mock_send_mail.call_args\n            self.assertEqual(args[0], 'Contact Form Submission')\n            self.assertIn('John Doe', args[1])\n\n# Mocking database queries\nclass OptimizedViewTest(TestCase):\n    def test_book_list_query_optimization(self):\n        # Create test data\n        author = UserFactory()\n        BookFactory.create_batch(10, author=author)\n        \n        with self.assertNumQueries(2):  # Should only make 2 queries\n            response = self.client.get('/books/')\n            self.assertEqual(response.status_code, 200)\n    \n    def test_book_detail_caching(self):\n        book = BookFactory()\n        \n        with patch('django.core.cache.cache.get') as mock_cache_get:\n            mock_cache_get.return_value = None  # Cache miss\n            \n            with patch('django.core.cache.cache.set') as mock_cache_set:\n                response = self.client.get(f'/books/{book.pk}/')\n                \n                # Verify cache was checked and set\n                mock_cache_get.assert_called_once()\n                mock_cache_set.assert_called_once()\n                self.assertEqual(response.status_code, 200)",
          followUp: "How would you implement integration tests with external services?"
        },
        {
          id: "test_4",
          question: "What are Django's debugging tools and how do you troubleshoot performance issues?",
          answer: "Django debugging tools:\n\n• Django Debug Toolbar: SQL queries, cache hits\n• django-extensions: shell_plus, runserver_plus\n• Python debugger (pdb): Breakpoints and inspection\n• Django logging: Custom loggers and handlers\n• Django admin: Data inspection\n• Management commands: Custom debugging commands\n• Browser developer tools: Network and performance\n\nPerformance troubleshooting:\n• Query optimization (select_related, prefetch_related)\n• Database indexing\n• Caching strategies\n• Template optimization\n• Memory profiling\n• CPU profiling\n• Database query analysis\n• Load testing tools\n\nProfiling tools:\n• Django Silk: Request profiling\n• cProfile: Python profiling\n• line_profiler: Line-by-line profiling\n• memory_profiler: Memory usage\n• py-spy: Sampling profiler\n• django-debug-toolbar: Database queries",
          difficulty: "advanced",
          tags: ["debugging", "performance", "profiling"],
          codeExample: "# Debug settings\n# settings/development.py\nif DEBUG:\n    import socket\n    \n    INSTALLED_APPS += [\n        'debug_toolbar',\n        'django_extensions',\n    ]\n    \n    MIDDLEWARE += [\n        'debug_toolbar.middleware.DebugToolbarMiddleware',\n    ]\n    \n    # Show debug toolbar on all IPs\n    INTERNAL_IPS = [\n        '127.0.0.1',\n        '10.0.2.2',\n    ]\n    \n    # Add docker IP if running in docker\n    hostname, _, ips = socket.gethostbyname_ex(socket.gethostname())\n    INTERNAL_IPS += [ip[:-1] + '1' for ip in ips]\n\n# Custom debugging decorator\nimport time\nimport functools\nfrom django.conf import settings\n\ndef debug_performance(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        if settings.DEBUG:\n            start_time = time.time()\n            result = func(*args, **kwargs)\n            end_time = time.time()\n            print(f'{func.__name__} took {end_time - start_time:.4f} seconds')\n            return result\n        return func(*args, **kwargs)\n    return wrapper\n\n# Usage in views\n@debug_performance\ndef slow_view(request):\n    # Simulate slow operation\n    books = Book.objects.all()\n    return render(request, 'books/list.html', {'books': books})\n\n# Logging configuration\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'verbose': {\n            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',\n            'style': '{',\n        },\n    },\n    'handlers': {\n        'file': {\n            'level': 'DEBUG',\n            'class': 'logging.FileHandler',\n            'filename': 'debug.log',\n            'formatter': 'verbose',\n        },\n        'console': {\n            'level': 'DEBUG',\n            'class': 'logging.StreamHandler',\n            'formatter': 'verbose',\n        },\n    },\n    'loggers': {\n        'django.db.backends': {\n            'handlers': ['file'],\n            'level': 'DEBUG',\n            'propagate': False,\n        },\n        'myapp': {\n            'handlers': ['file', 'console'],\n            'level': 'DEBUG',\n            'propagate': True,\n        },\n    },\n}\n\n# Custom management command for debugging\nfrom django.core.management.base import BaseCommand\nfrom django.db import connection\n\nclass Command(BaseCommand):\n    help = 'Debug database queries'\n    \n    def handle(self, *args, **options):\n        # Enable query logging\n        from django.conf import settings\n        settings.DEBUG = True\n        \n        # Run some queries\n        books = Book.objects.select_related('author').all()\n        \n        # Print query information\n        for query in connection.queries:\n            self.stdout.write(f\"Query: {query['sql']}\")\n            self.stdout.write(f\"Time: {query['time']}s\")\n            self.stdout.write(\"-\" * 50)\n        \n        self.stdout.write(f\"Total queries: {len(connection.queries)}\")\n\n# Memory profiling\nfrom memory_profiler import profile\n\n@profile\ndef memory_intensive_view(request):\n    # This will show memory usage line by line\n    large_list = []\n    for i in range(100000):\n        large_list.append(f'Item {i}')\n    \n    books = Book.objects.all()\n    return render(request, 'books/list.html', {\n        'books': books,\n        'large_list': large_list\n    })\n\n# Query analysis\nfrom django.db import connection\nfrom django.http import JsonResponse\n\ndef query_debug_view(request):\n    # Reset query log\n    connection.queries_log.clear()\n    \n    # Your view logic here\n    books = Book.objects.select_related('author').prefetch_related('categories')\n    \n    # Analyze queries\n    queries = connection.queries\n    query_info = []\n    \n    for query in queries:\n        query_info.append({\n            'sql': query['sql'],\n            'time': query['time'],\n            'duplicates': sum(1 for q in queries if q['sql'] == query['sql'])\n        })\n    \n    return JsonResponse({\n        'total_queries': len(queries),\n        'total_time': sum(float(q['time']) for q in queries),\n        'queries': query_info\n    })",
          followUp: "How would you implement automated performance regression testing?"
        },
        {
          id: "test_5",
          question: "How do you implement continuous integration and automated testing for Django?",
          answer: "Django CI/CD pipeline:\n\n• Version control integration (Git hooks)\n• Automated test execution\n• Code quality checks (linting, formatting)\n• Security scanning\n• Database migration testing\n• Multiple environment testing\n• Deployment automation\n• Monitoring and alerting\n\nCI/CD tools:\n• GitHub Actions\n• GitLab CI/CD\n• Jenkins\n• Travis CI\n• CircleCI\n• Azure DevOps\n• Bitbucket Pipelines\n\nBest practices:\n• Run tests on every commit\n• Parallel test execution\n• Test environment isolation\n• Artifact generation\n• Deployment rollback strategies\n• Environment-specific configurations\n• Monitoring and logging\n• Security scanning integration",
          difficulty: "advanced",
          tags: ["ci-cd", "automation", "testing"],
          codeExample: "# GitHub Actions workflow\n# .github/workflows/django.yml\nname: Django CI/CD\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    services:\n      postgres:\n        image: postgres:13\n        env:\n          POSTGRES_PASSWORD: postgres\n          POSTGRES_DB: test_db\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 5432:5432\n    \n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10]\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v3\n      with:\n        python-version: ${{ matrix.python-version }}\n    \n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n        pip install -r requirements-dev.txt\n    \n    - name: Run linting\n      run: |\n        flake8 .\n        black --check .\n        isort --check-only .\n    \n    - name: Run security checks\n      run: |\n        safety check\n        bandit -r .\n    \n    - name: Run tests\n      env:\n        DATABASE_URL: postgres://postgres:postgres@localhost:5432/test_db\n      run: |\n        python manage.py test --parallel\n        coverage run --source='.' manage.py test\n        coverage report\n        coverage xml\n    \n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v3\n      with:\n        file: ./coverage.xml\n        flags: unittests\n        name: codecov-umbrella\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Deploy to production\n      run: |\n        echo \"Deploying to production...\"\n        # Add deployment steps here\n\n# Custom test runner for parallel testing\n# test_runner.py\nfrom django.test.runner import DiscoverRunner\nimport sys\n\nclass ParallelTestRunner(DiscoverRunner):\n    def run_tests(self, test_labels, extra_tests=None, **kwargs):\n        # Enable parallel testing\n        self.parallel = True\n        \n        # Run tests\n        result = super().run_tests(test_labels, extra_tests, **kwargs)\n        \n        # Exit with appropriate code\n        sys.exit(bool(result))\n\n# tox.ini for testing multiple environments\n[tox]\nenvlist = py38-django32, py39-django32, py310-django40, flake8, mypy\n\n[testenv]\ndeps = \n    django32: Django>=3.2,<4.0\n    django40: Django>=4.0,<4.1\n    -r requirements-dev.txt\ncommands = \n    python manage.py test\n    coverage run --source='.' manage.py test\n    coverage report\n\n[testenv:flake8]\ndeps = flake8\ncommands = flake8 .\n\n[testenv:mypy]\ndeps = mypy\ncommands = mypy .\n\n# Makefile for common tasks\nMAKEFILE = Makefile\n\n.PHONY: test\ntest:\n\tpython manage.py test --parallel\n\n.PHONY: coverage\ncoverage:\n\tcoverage run --source='.' manage.py test\n\tcoverage report\n\tcoverage html\n\n.PHONY: lint\nlint:\n\tflake8 .\n\tblack --check .\n\tisort --check-only .\n\n.PHONY: format\nformat:\n\tblack .\n\tisort .\n\n.PHONY: security\nsecurity:\n\tsafety check\n\tbandit -r .\n\n.PHONY: migrate\nmigrate:\n\tpython manage.py makemigrations\n\tpython manage.py migrate\n\n.PHONY: install\ninstall:\n\tpip install -r requirements.txt\n\tpip install -r requirements-dev.txt\n\n.PHONY: clean\nclean:\n\tfind . -type f -name '*.pyc' -delete\n\tfind . -type d -name '__pycache__' -delete\n\trm -rf .coverage htmlcov/\n\n# Pre-commit hooks\n# .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-added-large-files\n  \n  - repo: https://github.com/psf/black\n    rev: 22.10.0\n    hooks:\n      - id: black\n  \n  - repo: https://github.com/pycqa/isort\n    rev: 5.10.1\n    hooks:\n      - id: isort\n  \n  - repo: https://github.com/pycqa/flake8\n    rev: 5.0.4\n    hooks:\n      - id: flake8",
          followUp: "How would you implement blue-green deployment for Django applications?"
        },
        {
          id: "test_6",
          question: "How do you implement load testing and performance monitoring for Django?",
          answer: "Django load testing and monitoring:\n\nLoad testing tools:\n• Locust: Python-based load testing\n• Apache JMeter: GUI-based testing\n• Artillery: Node.js testing framework\n• wrk: HTTP benchmarking tool\n• Gatling: High-performance testing\n• Django-silk: Request profiling\n\nMonitoring solutions:\n• New Relic: Application performance monitoring\n• Datadog: Infrastructure and application monitoring\n• Sentry: Error tracking and performance\n• Prometheus + Grafana: Metrics collection\n• ELK Stack: Log aggregation and analysis\n• Django-health-check: Health endpoints\n\nPerformance metrics:\n• Response time\n• Throughput (requests per second)\n• Error rate\n• Resource utilization (CPU, memory)\n• Database query performance\n• Cache hit rates\n• Queue processing times",
          difficulty: "expert",
          tags: ["load-testing", "monitoring", "performance"],
          codeExample: "# Locust load testing\n# locustfile.py\nfrom locust import HttpUser, task, between\nimport random\n\nclass WebsiteUser(HttpUser):\n    wait_time = between(1, 3)\n    \n    def on_start(self):\n        # Login before starting tests\n        self.client.post('/login/', {\n            'username': 'testuser',\n            'password': 'testpass'\n        })\n    \n    @task(3)\n    def view_books(self):\n        self.client.get('/books/')\n    \n    @task(2)\n    def view_book_detail(self):\n        book_id = random.randint(1, 100)\n        self.client.get(f'/books/{book_id}/')\n    \n    @task(1)\n    def search_books(self):\n        query = random.choice(['python', 'django', 'programming'])\n        self.client.get(f'/books/search/?q={query}')\n    \n    @task(1)\n    def api_endpoint(self):\n        self.client.get('/api/books/', headers={\n            'Authorization': 'Token your-token-here'\n        })\n    \n    def test_form_submission(self):\n        # Test form submission\n        response = self.client.get('/contact/')\n        csrf_token = response.cookies.get('csrftoken')\n        \n        self.client.post('/contact/', {\n            'name': 'Test User',\n            'email': 'test@example.com',\n            'message': 'Test message',\n            'csrfmiddlewaretoken': csrf_token\n        })\n\n# Performance monitoring middleware\nimport time\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.conf import settings\nimport logging\n\nperformance_logger = logging.getLogger('performance')\n\nclass PerformanceMonitoringMiddleware(MiddlewareMixin):\n    def process_request(self, request):\n        request.start_time = time.time()\n    \n    def process_response(self, request, response):\n        if hasattr(request, 'start_time'):\n            duration = time.time() - request.start_time\n            \n            # Log slow requests\n            if duration > 1.0:  # Log requests taking more than 1 second\n                performance_logger.warning(\n                    f'Slow request: {request.method} {request.path} - {duration:.2f}s',\n                    extra={\n                        'method': request.method,\n                        'path': request.path,\n                        'duration': duration,\n                        'status_code': response.status_code,\n                        'user': getattr(request, 'user', None)\n                    }\n                )\n            \n            # Add performance headers\n            response['X-Response-Time'] = f'{duration:.3f}'\n            \n            # Send metrics to monitoring service\n            if hasattr(settings, 'METRICS_BACKEND'):\n                self.send_metrics(request, response, duration)\n        \n        return response\n    \n    def send_metrics(self, request, response, duration):\n        # Send metrics to your monitoring service\n        # This could be StatsD, Prometheus, etc.\n        pass\n\n# Custom management command for health checks\nfrom django.core.management.base import BaseCommand\nfrom django.db import connection\nfrom django.core.cache import cache\nfrom django.http import JsonResponse\n\nclass Command(BaseCommand):\n    help = 'Health check command'\n    \n    def handle(self, *args, **options):\n        health_status = {\n            'status': 'healthy',\n            'timestamp': timezone.now().isoformat(),\n            'checks': {}\n        }\n        \n        # Database check\n        try:\n            with connection.cursor() as cursor:\n                cursor.execute('SELECT 1')\n                health_status['checks']['database'] = 'healthy'\n        except Exception as e:\n            health_status['checks']['database'] = f'unhealthy: {str(e)}'\n            health_status['status'] = 'unhealthy'\n        \n        # Cache check\n        try:\n            cache.set('health_check', 'ok', 30)\n            cache.get('health_check')\n            health_status['checks']['cache'] = 'healthy'\n        except Exception as e:\n            health_status['checks']['cache'] = f'unhealthy: {str(e)}'\n            health_status['status'] = 'unhealthy'\n        \n        # Custom checks\n        health_status['checks']['custom'] = self.custom_health_checks()\n        \n        self.stdout.write(json.dumps(health_status, indent=2))\n    \n    def custom_health_checks(self):\n        # Add your custom health checks here\n        return 'healthy'\n\n# Sentry integration for error tracking\nimport sentry_sdk\nfrom sentry_sdk.integrations.django import DjangoIntegration\nfrom sentry_sdk.integrations.logging import LoggingIntegration\n\nsentry_logging = LoggingIntegration(\n    level=logging.INFO,\n    event_level=logging.ERROR\n)\n\nsentry_sdk.init(\n    dsn='YOUR_SENTRY_DSN',\n    integrations=[\n        DjangoIntegration(transaction_style='url'),\n        sentry_logging,\n    ],\n    traces_sample_rate=1.0,\n    send_default_pii=True,\n    environment='production'\n)\n\n# Custom metrics collection\nimport statsd\nfrom django.conf import settings\n\nclass MetricsCollector:\n    def __init__(self):\n        self.client = statsd.StatsClient(\n            host=settings.STATSD_HOST,\n            port=settings.STATSD_PORT,\n            prefix='django_app'\n        )\n    \n    def increment(self, metric, value=1, tags=None):\n        self.client.incr(metric, value)\n    \n    def timing(self, metric, value, tags=None):\n        self.client.timing(metric, value)\n    \n    def gauge(self, metric, value, tags=None):\n        self.client.gauge(metric, value)\n\n# Usage in views\nmetrics = MetricsCollector()\n\ndef book_list_view(request):\n    start_time = time.time()\n    \n    try:\n        books = Book.objects.all()\n        metrics.increment('views.book_list.success')\n        \n        duration = (time.time() - start_time) * 1000  # Convert to milliseconds\n        metrics.timing('views.book_list.duration', duration)\n        \n        return render(request, 'books/list.html', {'books': books})\n    \n    except Exception as e:\n        metrics.increment('views.book_list.error')\n        raise",
          followUp: "How would you implement automated performance regression detection?"
        }
      ]
    },
    {
      title: "Performance & Scalability",
      icon: "settings",
      story: {
        title: "The Scale Challenge",
        content: "User traffic has exploded overnight. The application that was serving 100 users now has 10,000 concurrent users, and everything is breaking. Database queries are timing out, the server is running out of memory, and users are complaining about slow page loads. The CEO calls an emergency meeting: 'Alex, we need to scale this application immediately. What's your plan?'",
        context: "This section covers Django performance optimization, caching, database optimization, and scalability strategies."
      },
      questions: [
        {
          id: "perf_1",
          question: "How do you identify and fix database performance bottlenecks in Django?",
          answer: "Database performance optimization in Django:\n\nIdentification tools:\n• Django Debug Toolbar for query analysis\n• django-silk for request profiling\n• Database query logs and slow query logs\n• django.db.backends logging\n• Connection query counting\n• Database performance monitoring tools\n\nCommon bottlenecks:\n• N+1 query problems\n• Missing database indexes\n• Unnecessary data fetching\n• Inefficient ORM queries\n• Lack of query optimization\n• Database connection pooling issues\n\nOptimization strategies:\n• Use select_related() and prefetch_related()\n• Add database indexes\n• Optimize query patterns\n• Use raw SQL for complex queries\n• Implement database connection pooling\n• Use database query caching\n• Implement read replicas",
          difficulty: "advanced",
          tags: ["database", "optimization", "performance"],
          codeExample: "# Query optimization examples\n\n# Bad - N+1 query problem\ndef book_list_bad(request):\n    books = Book.objects.all()\n    for book in books:\n        print(book.author.name)  # Database hit for each book\n    return render(request, 'books/list.html', {'books': books})\n\n# Good - Using select_related\ndef book_list_good(request):\n    books = Book.objects.select_related('author').all()\n    for book in books:\n        print(book.author.name)  # No additional queries\n    return render(request, 'books/list.html', {'books': books})\n\n# Complex query optimization\ndef book_stats_optimized(request):\n    from django.db.models import Count, Avg, Prefetch\n    \n    # Optimized query with annotations and prefetch\n    books = Book.objects.select_related('author').prefetch_related(\n        Prefetch(\n            'reviews',\n            queryset=Review.objects.select_related('user')\n        )\n    ).annotate(\n        review_count=Count('reviews'),\n        average_rating=Avg('reviews__rating')\n    )\n    \n    return render(request, 'books/stats.html', {'books': books})\n\n# Custom manager for optimized queries\nclass OptimizedBookManager(models.Manager):\n    def with_author_and_stats(self):\n        return self.get_queryset().select_related('author').annotate(\n            review_count=Count('reviews'),\n            average_rating=Avg('reviews__rating')\n        )\n    \n    def popular_books(self, limit=10):\n        return self.with_author_and_stats().filter(\n            review_count__gt=5\n        ).order_by('-average_rating')[:limit]\n\n# Database indexing\nclass Book(models.Model):\n    title = models.CharField(max_length=200, db_index=True)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n    isbn = models.CharField(max_length=13, unique=True, db_index=True)\n    publication_date = models.DateField(db_index=True)\n    \n    objects = OptimizedBookManager()\n    \n    class Meta:\n        indexes = [\n            models.Index(fields=['title', 'author']),\n            models.Index(fields=['publication_date', '-title']),\n            models.Index(fields=['author', '-publication_date']),\n        ]\n\n# Query monitoring middleware\nclass QueryCountMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n    \n    def __call__(self, request):\n        from django.db import connection, reset_queries\n        \n        reset_queries()\n        \n        response = self.get_response(request)\n        \n        query_count = len(connection.queries)\n        query_time = sum(float(q['time']) for q in connection.queries)\n        \n        # Log if too many queries\n        if query_count > 10:\n            logger.warning(\n                f'High query count: {query_count} queries in {query_time:.2f}s for {request.path}',\n                extra={\n                    'query_count': query_count,\n                    'query_time': query_time,\n                    'path': request.path\n                }\n            )\n        \n        # Add headers for debugging\n        response['X-Query-Count'] = str(query_count)\n        response['X-Query-Time'] = f'{query_time:.2f}'\n        \n        return response\n\n# Raw SQL for complex queries\nfrom django.db import connection\n\ndef get_book_analytics():\n    with connection.cursor() as cursor:\n        cursor.execute(\"\"\"\n            SELECT \n                b.id,\n                b.title,\n                a.name as author_name,\n                COUNT(r.id) as review_count,\n                AVG(r.rating) as average_rating,\n                COUNT(DISTINCT r.user_id) as unique_reviewers\n            FROM books_book b\n            JOIN authors_author a ON b.author_id = a.id\n            LEFT JOIN reviews_review r ON b.id = r.book_id\n            WHERE b.publication_date >= %s\n            GROUP BY b.id, b.title, a.name\n            HAVING COUNT(r.id) > 0\n            ORDER BY average_rating DESC, review_count DESC\n            LIMIT 20\n        \"\"\", [timezone.now() - timedelta(days=365)])\n        \n        columns = [col[0] for col in cursor.description]\n        return [\n            dict(zip(columns, row))\n            for row in cursor.fetchall()\n        ]",
          followUp: "How would you implement database sharding for a Django application?"
        },
        {
          id: "perf_2",
          question: "Explain Django's caching framework and implement a multi-level caching strategy.",
          answer: "Django caching framework:\n\nCaching levels:\n• Browser caching (HTTP headers)\n• CDN caching (static assets)\n• Full-page caching (entire pages)\n• Template fragment caching (parts of templates)\n• Database query caching (ORM results)\n• Object-level caching (model instances)\n• API response caching (REST endpoints)\n\nCaching backends:\n• Redis: Production-ready, distributed\n• Memcached: High-performance, simple\n• Database cache: Development/testing\n• File-based cache: Single server\n• Dummy cache: Testing/development\n\nCaching strategies:\n• Cache-aside (lazy loading)\n• Write-through caching\n• Write-behind caching\n• Cache warming\n• Cache invalidation\n• TTL (Time To Live) management",
          difficulty: "advanced",
          tags: ["caching", "performance", "redis"],
          codeExample: "# Multi-level caching implementation\n\n# Settings configuration\nCACHES = {\n    'default': {\n        'BACKEND': 'django_redis.cache.RedisCache',\n        'LOCATION': 'redis://127.0.0.1:6379/1',\n        'OPTIONS': {\n            'CLIENT_CLASS': 'django_redis.client.DefaultClient',\n            'SERIALIZER': 'django_redis.serializers.json.JSONSerializer',\n            'COMPRESSOR': 'django_redis.compressors.zlib.ZlibCompressor',\n        },\n        'KEY_PREFIX': 'myapp',\n        'TIMEOUT': 300,  # 5 minutes default\n    },\n    'session': {\n        'BACKEND': 'django_redis.cache.RedisCache',\n        'LOCATION': 'redis://127.0.0.1:6379/2',\n        'OPTIONS': {\n            'CLIENT_CLASS': 'django_redis.client.DefaultClient',\n        },\n        'KEY_PREFIX': 'session',\n    },\n    'long_term': {\n        'BACKEND': 'django_redis.cache.RedisCache',\n        'LOCATION': 'redis://127.0.0.1:6379/3',\n        'OPTIONS': {\n            'CLIENT_CLASS': 'django_redis.client.DefaultClient',\n        },\n        'KEY_PREFIX': 'longterm',\n        'TIMEOUT': 86400,  # 24 hours\n    }\n}\n\n# Session configuration\nSESSION_ENGINE = 'django.contrib.sessions.backends.cache'\nSESSION_CACHE_ALIAS = 'session'\n\n# Custom cache service\nfrom django.core.cache import caches\nfrom django.core.cache.utils import make_key\nimport hashlib\nimport json\n\nclass CacheService:\n    def __init__(self):\n        self.default_cache = caches['default']\n        self.long_term_cache = caches['long_term']\n    \n    def get_cache_key(self, prefix, *args, **kwargs):\n        \"\"\"Generate consistent cache keys\"\"\"\n        key_parts = [str(arg) for arg in args]\n        key_parts.extend([f'{k}:{v}' for k, v in sorted(kwargs.items())])\n        key_data = ':'.join(key_parts)\n        key_hash = hashlib.md5(key_data.encode()).hexdigest()\n        return f'{prefix}:{key_hash}'\n    \n    def get_or_set(self, key, callable_func, timeout=300, cache_alias='default'):\n        \"\"\"Get from cache or set with callable\"\"\"\n        cache = caches[cache_alias]\n        value = cache.get(key)\n        if value is None:\n            value = callable_func()\n            cache.set(key, value, timeout)\n        return value\n    \n    def invalidate_pattern(self, pattern):\n        \"\"\"Invalidate keys matching pattern\"\"\"\n        from django_redis import get_redis_connection\n        conn = get_redis_connection('default')\n        keys = conn.keys(pattern)\n        if keys:\n            conn.delete(*keys)\n\n# Model-level caching\nclass CachedBookManager(models.Manager):\n    def __init__(self):\n        super().__init__()\n        self.cache_service = CacheService()\n    \n    def get_by_id(self, book_id):\n        cache_key = f'book:{book_id}'\n        return self.cache_service.get_or_set(\n            cache_key,\n            lambda: self.select_related('author').get(id=book_id),\n            timeout=600  # 10 minutes\n        )\n    \n    def get_popular_books(self, limit=10):\n        cache_key = f'popular_books:{limit}'\n        return self.cache_service.get_or_set(\n            cache_key,\n            lambda: list(self.filter(is_popular=True)[:limit]),\n            timeout=3600,  # 1 hour\n            cache_alias='long_term'\n        )\n    \n    def get_books_by_author(self, author_id):\n        cache_key = f'books_by_author:{author_id}'\n        return self.cache_service.get_or_set(\n            cache_key,\n            lambda: list(self.filter(author_id=author_id)),\n            timeout=1800  # 30 minutes\n        )\n\n# View-level caching\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.vary import vary_on_headers\nfrom django.utils.decorators import method_decorator\n\n@cache_page(60 * 15)  # Cache for 15 minutes\n@vary_on_headers('User-Agent')\ndef book_list_cached(request):\n    books = Book.objects.all()\n    return render(request, 'books/list.html', {'books': books})\n\n# Class-based view caching\n@method_decorator(cache_page(60 * 15), name='dispatch')\nclass BookListView(ListView):\n    model = Book\n    template_name = 'books/list.html'\n    context_object_name = 'books'\n\n# API response caching\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nclass BookAPIView(APIView):\n    def get(self, request):\n        cache_key = self.get_cache_key(request)\n        cached_data = cache.get(cache_key)\n        \n        if cached_data is not None:\n            return Response(cached_data)\n        \n        # Generate data\n        books = Book.objects.select_related('author').all()\n        serializer = BookSerializer(books, many=True)\n        data = serializer.data\n        \n        # Cache the response\n        cache.set(cache_key, data, timeout=300)\n        \n        return Response(data)\n    \n    def get_cache_key(self, request):\n        user_id = request.user.id if request.user.is_authenticated else 'anonymous'\n        query_params = request.GET.dict()\n        cache_key = f'book_api:{user_id}:{hash(frozenset(query_params.items()))}'\n        return cache_key\n\n# Template fragment caching\n# In template:\n\"\"\"\n{% load cache %}\n\n{% cache 500 book_sidebar book.id %}\n    <div class=\"sidebar\">\n        <h3>Related Books</h3>\n        {% for related_book in book.get_related_books %}\n            <p>{{ related_book.title }}</p>\n        {% endfor %}\n    </div>\n{% endcache %}\n\"\"\"\n\n# Cache warming management command\nfrom django.core.management.base import BaseCommand\n\nclass Command(BaseCommand):\n    help = 'Warm up cache with frequently accessed data'\n    \n    def handle(self, *args, **options):\n        cache_service = CacheService()\n        \n        # Warm up popular books\n        self.stdout.write('Warming up popular books...')\n        popular_books = Book.objects.get_popular_books()\n        \n        # Warm up author data\n        self.stdout.write('Warming up author data...')\n        for author in Author.objects.all():\n            cache_key = f'author_books:{author.id}'\n            books = Book.objects.filter(author=author)\n            cache.set(cache_key, list(books), timeout=3600)\n        \n        # Warm up search results\n        self.stdout.write('Warming up search results...')\n        popular_queries = ['python', 'django', 'programming']\n        for query in popular_queries:\n            cache_key = f'search:{query}'\n            results = Book.objects.filter(title__icontains=query)\n            cache.set(cache_key, list(results), timeout=1800)\n        \n        self.stdout.write(self.style.SUCCESS('Cache warming completed!'))\n\n# Cache invalidation signals\nfrom django.db.models.signals import post_save, post_delete\nfrom django.dispatch import receiver\n\n@receiver(post_save, sender=Book)\ndef invalidate_book_cache(sender, instance, **kwargs):\n    cache_service = CacheService()\n    \n    # Invalidate specific book cache\n    cache.delete(f'book:{instance.id}')\n    \n    # Invalidate related caches\n    cache.delete(f'books_by_author:{instance.author_id}')\n    cache.delete('popular_books:*')\n    \n    # Invalidate search caches\n    cache_service.invalidate_pattern('search:*')\n\n@receiver(post_delete, sender=Book)\ndef invalidate_book_cache_on_delete(sender, instance, **kwargs):\n    cache_service = CacheService()\n    cache.delete(f'book:{instance.id}')\n    cache.delete(f'books_by_author:{instance.author_id}')\n    cache_service.invalidate_pattern('popular_books:*')",
          followUp: "How would you implement cache coherency across multiple Django instances?"
        }
      ]
    }
  ]
};